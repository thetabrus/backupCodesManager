<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link rel="icon" type="image/x-icon" href="backupcodesmanager.ico" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <title>Backup Codes Manager</title>
    <style>
      :root {
        --m3-primary: #00677f; /* Deep teal/blue */
        --m3-on-primary: #ffffff;
        --m3-primary-container: #bee9ff;
        --m3-on-primary-container: #001f28;

        --m3-secondary: #4e626a;
        --m3-on-secondary: #ffffff;
        --m3-secondary-container: #d1e6ee;
        --m3-on-secondary-container: #091f26;

        --m3-tertiary: #5e5b7d;
        --m3-on-tertiary: #ffffff;
        --m3-tertiary-container: #e4dfff;
        --m3-on-tertiary-container: #1a1836;

        --m3-error: #ba1a1a;
        --m3-on-error: #ffffff;
        --m3-error-container: #ffdad6;
        --m3-on-error-container: #410002;

        --m3-background: #f7fcff;
        --m3-on-background: #171d1f;

        --m3-surface: #ffffff;
        --m3-on-surface: #171d1f;
        --m3-surface-variant: #dbe4e8;
        --m3-on-surface-variant: #40484c;

        --m3-outline: #70787c;
        --m3-shadow-color: rgba(0, 0, 0, 0.1);
        --m3-shadow-elevation-1: 0 1px 2px 0 var(--m3-shadow-color),
          0 1px 3px 0 var(--m3-shadow-color);
        --m3-shadow-elevation-2: 0 2px 4px -1px var(--m3-shadow-color),
          0 4px 5px 0 var(--m3-shadow-color);
        --m3-shadow-elevation-3: 0 4px 6px -2px var(--m3-shadow-color),
          0 6px 10px 0 var(--m3-shadow-color);

        --m3-border-radius-s: 4px;
        --m3-border-radius-m: 8px;
        --m3-border-radius-l: 16px;
        --m3-border-radius-xl: 28px;

        --m3-spacing-xs: 4px;
        --m3-spacing-s: 8px;
        --m3-spacing-m: 16px;
        --m3-spacing-l: 24px;
        --m3-spacing-xl: 32px;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      @font-face {
        font-family: "NotoSansUnicode";
        src: url("./NotoSans-Regular.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
      }
      @font-face {
        font-family: "NotoSansUnicode";
        src: url("./NotoSans-Bold.ttf") format("truetype");
        font-weight: bold;
        font-style: normal;
      }
      body {
        font-family: "NotoSansUnicode", -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol";
        margin: 0;
        padding: var(--m3-spacing-l);
        background-color: var(--m3-background);
        color: var(--m3-on-background);
        line-height: 1.6;
      }

      body > h1,
      #rawSection,
      #editForm,
      #printQueueSection {
        width: 100%;
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: var(--m3-spacing-l);
      }

      #printQueueSection legend {
        float: left;
        width: auto;
      }

      #originalTextSection legend,
      #printDataSection legend {
        float: left;
        width: auto;
      }

      h1 {
        font-size: 2.25rem;
        font-weight: 700;
        color: var(--m3-primary);
        margin-bottom: var(--m3-spacing-xl);
        text-align: center;
      }

      textarea,
      input,
      button,
      fieldset {
        font-family: inherit;
      }

      textarea {
        width: 100%;
        min-height: 150px;
        margin-bottom: var(--m3-spacing-m);
        padding: var(--m3-spacing-m);
        border: 1px solid var(--m3-outline);
        border-radius: var(--m3-border-radius-m);
        background-color: var(--m3-surface);
        color: var(--m3-on-surface);
        font-size: 1rem;
        line-height: 1.5;
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      }
      textarea:focus {
        outline: none;
        border-color: var(--m3-primary);
        box-shadow: 0 0 0 2px var(--m3-primary-container);
      }

      fieldset,
      #rawSection {
        padding: var(--m3-spacing-l);
        padding-right: var(--m3-spacing-l);
        padding-bottom: var(--m3-spacing-l);
        background-color: var(--m3-surface);
        border: none;
        border-radius: var(--m3-border-radius-l);
        margin: 0 auto var(--m3-spacing-l) auto;
        box-shadow: var(--m3-shadow-elevation-1);
      }
      #rawSection > p {
        margin-top: 0;
        margin-bottom: var(--m3-spacing-m);
        font-size: 1.1rem;
        color: var(--m3-on-surface-variant);
      }

      legend {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--m3-on-surface-variant);
        padding-left: 0;
        padding-right: 0;
        padding-bottom: var(--m3-spacing-xs);
        margin-left: 0;
        margin-right: 0;
        margin-bottom: var(--m3-spacing-m);
        border-bottom: 1px solid var(--m3-surface-variant);
        display: block;
        box-sizing: border-box;
      }
      .section-header {
        display: flex;
        align-items: center;
        font-weight: 500;
        font-size: 1.1rem;
        color: var(--m3-on-surface-variant);
        margin-top: var(--m3-spacing-l);
        margin-bottom: var(--m3-spacing-s); /* Space before input */
      }
      .section-header input[type="checkbox"],
      .master-check input[type="checkbox"],
      .code-item input[type="checkbox"],
      #menuPdfModeCheckbox {
        margin-right: var(--m3-spacing-s);
        width: 20px;
        height: 20px;
        accent-color: var(--m3-primary);
        cursor: pointer;
        flex-shrink: 0;
      }
      .section-header label,
      .master-check label,
      .code-item label,
      label[for="menuPdfModeCheckbox"] {
        font-size: 1rem;
        color: var(--m3-on-surface);
        cursor: pointer;
      }

      input[type="text"] {
        width: 100%;
        padding: var(--m3-spacing-m);
        margin-bottom: var(--m3-spacing-m);
        border: 1px solid var(--m3-outline);
        border-radius: var(--m3-border-radius-m);
        background-color: var(--m3-surface);
        color: var(--m3-on-surface);
        font-size: 1rem;
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      }
      input[type="text"]:focus {
        outline: none;
        border-color: var(--m3-primary);
        box-shadow: 0 0 0 2px var(--m3-primary-container);
      }

      .codes-container {
        margin: var(--m3-spacing-m) 0;
        display: flex;
        flex-direction: column;
        gap: var(--m3-spacing-s);
      }

      .code-item {
        display: flex;
        align-items: center;
        gap: var(--m3-spacing-s);
        background-color: var(--m3-surface-variant);
        padding: var(--m3-spacing-s);
        border-radius: var(--m3-border-radius-m);
      }

      .code-item input[type="text"] {
        flex: 1;
        margin-bottom: 0;
        background-color: var(--m3-surface);
      }

      .master-check {
        display: flex;
        align-items: center;
        margin: var(--m3-spacing-l) 0; /* More space around master check */
        font-weight: 500;
      }

      button,
      .button-like-label {
        padding: var(--m3-spacing-s) var(--m3-spacing-m);
        font-size: 1rem;
        border-radius: var(--m3-border-radius-xl);
        cursor: pointer;
        border: none;
        font-weight: 500;
        line-height: normal;
        transition: background-color 0.2s ease, box-shadow 0.2s ease,
          filter 0.2s ease;
        text-align: center;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--m3-spacing-s);
        margin-right: var(--m3-spacing-s);
        margin-bottom: var(--m3-spacing-s);
      }
      button:last-child,
      .button-like-label:last-child {
        margin-right: 0;
      }

      button#parseBtn,
      button#addToQueueBtn,
      button#printAllQueuedBtn {
        background-color: var(--m3-primary);
        color: var(--m3-on-primary);
      }
      button#parseBtn:hover,
      button#addToQueueBtn:hover,
      button#printAllQueuedBtn:hover {
        filter: brightness(0.9);
        box-shadow: var(--m3-shadow-elevation-1);
      }

      button#downloadJsonBtn,
      button#clearQueueBtn,
      button#cancelBtn {
        background-color: var(--m3-surface-variant);
        color: var(--m3-on-surface-variant);
        border: 1px solid var(--m3-outline);
      }
      button#downloadJsonBtn:hover,
      button#clearQueueBtn:hover,
      button#cancelBtn:hover {
        background-color: var(--m3-secondary-container);
        color: var(--m3-on-secondary-container);
        border-color: var(--m3-secondary);
      }

      button#addCodeBtn {
        background-color: var(--m3-tertiary-container);
        color: var(--m3-on-tertiary-container);
        padding: var(--m3-spacing-s) var(--m3-spacing-m);
        margin: var(--m3-spacing-m) 0;
      }
      button#addCodeBtn:hover {
        filter: brightness(0.9);
      }

      .code-item button {
        padding: var(--m3-spacing-xs) var(--m3-spacing-s);
        min-width: auto;
        border-radius: var(--m3-border-radius-s);
        background-color: var(--m3-error-container);
        color: var(--m3-on-error-container);
        border: none;
        margin-right: 0;
      }
      .code-item button:hover {
        filter: brightness(0.9);
      }

      .button-like-label {
        background-color: var(--m3-surface-variant);
        color: var(--m3-on-surface-variant);
        border: 1px solid var(--m3-outline);
      }
      .button-like-label:hover {
        background-color: var(--m3-secondary-container);
        color: var(--m3-on-secondary-container);
        border-color: var(--m3-secondary);
      }
      .error {
        color: var(--m3-on-error-container); /* Text color for error messages */
        background-color: var(
          --m3-error-container
        ); /* Background for error messages */
        padding: var(--m3-spacing-s) var(--m3-spacing-m); /* Padding within error messages */
        border-radius: var(
          --m3-border-radius-m
        ); /* Rounded corners for error messages */
        margin-bottom: var(--m3-spacing-m); /* Space below error messages */
        font-weight: 500; /* Medium weight for error text */
        display: none;
      }
      #rawInputError {
        margin-top: var(--m3-spacing-s);
      }

      #appMenuContainer {
        position: fixed;
        bottom: var(--m3-spacing-l);
        right: var(--m3-spacing-l);
        z-index: 1000;
      }
      #mainMenuBtn {
        cursor: pointer;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 56px;
        height: 56px;
        background: var(--m3-secondary-container);
        color: var(--m3-on-secondary-container);
        border: none;
        border-radius: var(--m3-border-radius-l);
        box-shadow: var(--m3-shadow-elevation-3);
        transition: transform 0.2s ease-out, box-shadow 0.2s ease-out,
          background-color 0.2s ease;
        margin: 0;
      }
      #mainMenuBtn:hover {
        transform: scale(1.05);
        background-color: color-mix(
          in srgb,
          var(--m3-secondary-container) 90%,
          black
        );
      }
      #mainMenuBtn .material-icons {
        font-size: 28px;
      }

      #appMenuItems {
        position: absolute;
        bottom: calc(100% + var(--m3-spacing-s));
        right: 0;
        background: var(--m3-surface);
        border: 1px solid var(--m3-surface-variant);
        border-radius: var(--m3-border-radius-m);
        box-shadow: var(--m3-shadow-elevation-2);
        padding: var(--m3-spacing-s) 0;
        min-width: 220px;
        z-index: 1001;
        display: none;
      }

      .app-menu-item {
        padding: var(--m3-spacing-s) var(--m3-spacing-m);
        cursor: pointer;
        display: flex;
        align-items: center;
        font-size: 1rem;
        color: var(--m3-on-surface);
        gap: var(--m3-spacing-m);
        transition: background-color 0.15s ease;
      }
      .app-menu-item:hover {
        background-color: var(--m3-surface-variant);
      }
      .app-menu-item .material-icons {
        font-size: 22px;
        color: var(--m3-on-surface-variant);
      }
      .app-menu-item .material-icons {
        font-size: 22px;
        color: var(--m3-on-surface-variant);
      }

      #queueControls {
        display: flex;
        flex-wrap: wrap;
        gap: var(--m3-spacing-m);
        margin-bottom: var(--m3-spacing-l);
        align-items: center;
      }
      #printQueueSection legend + #queueControls {
        clear: both;
      }
      #originalTextSection legend + #previewRaw {
        clear: both;
      }

      /* Clear the float for Print Data legend (targets the first .section-header) */
      #printDataSection legend + .section-header {
        clear: both;
      }

      #printQueueList {
        list-style: none;
        padding: 0;
        margin: 0 0 var(--m3-spacing-l) 0;
        display: flex;
        flex-direction: column;
        gap: var(--m3-spacing-s);
      }
      #printQueueList li {
        background-color: var(--m3-surface-variant);
        padding: var(--m3-spacing-m);
        border-radius: var(--m3-border-radius-m);
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--m3-on-surface-variant);
        font-size: 1rem;
      }
      #printQueueList li button {
        margin-left: var(--m3-spacing-m);
        background-color: var(--m3-error-container);
        color: var(--m3-on-error-container);
        border: none;
        padding: var(--m3-spacing-xs) var(--m3-spacing-s);
        border-radius: var(--m3-border-radius-s);
      }
      #printQueueList li button:hover {
        filter: brightness(0.9);
      }
      #queueStatus {
        color: var(--m3-on-surface-variant);
        text-align: center;
        padding: var(--m3-spacing-m);
        background-color: var(--m3-surface-variant);
        border-radius: var(--m3-border-radius-m);
      }
      #queueStatus {
        display: none;
      }

      @media print {
        body {
          margin: 0;
          background-color: transparent;
        }
        .block {
          width: 105mm;
          height: 74mm;
          box-sizing: border-box;
          padding: 8mm;
          page-break-after: always;
        }
        .block input[type="checkbox"] {
          transform: scale(1.2);
          margin-right: 6px;
        }
      }
    </style>
  </head>
  <body>
    <h1>Backup 2FA Codes Manager</h1>

    <div id="appMenuContainer">
      <div id="appMenuItems">
        <div class="app-menu-item" id="menuItemTestParser">
          <span class="material-icons">science</span>
          Test Parser
        </div>
        <div class="app-menu-item">
          <input type="checkbox" id="menuPdfModeCheckbox" />
          <label for="menuPdfModeCheckbox">PDF Mode</label>
        </div>
      </div>

      <button id="mainMenuBtn" title="Menu">
        <span class="material-icons">menu</span>
      </button>
    </div>

    <div id="rawSection">
      <p>Paste the raw text with the list of backup codes:</p>
      <textarea id="rawInput" placeholder="Paste raw text..."></textarea>
      <span id="rawInputError" class="error"></span>
      <button id="parseBtn">Parse and Edit</button>
    </div>
    <form id="editForm">
      <fieldset id="originalTextSection">
        <legend>Original Text</legend>
        <textarea id="previewRaw" readonly></textarea>
      </fieldset>
      <fieldset id="printDataSection">
        <legend>Print Data</legend>
        <div class="section-header">
          <input type="checkbox" id="checkService" /><label for="serviceInput"
            >Service Name</label
          >
        </div>
        <input type="text" id="serviceInput" />
        <div class="section-header">
          <input type="checkbox" id="checkLogin" /><label for="loginInput"
            >Email/Login</label
          >
        </div>
        <input type="text" id="loginInput" />
        <div class="section-header">
          <input type="checkbox" id="checkAllCodes" /><label
            >List of Codes</label
          >
        </div>
        <div class="codes-container" id="codesContainer"></div>
        <button type="button" id="addCodeBtn">+ Add Code</button>
        <div class="section-header">
          <input type="checkbox" id="checkNote" /><label for="noteInput"
            >Note</label
          >
        </div>
        <input type="text" id="noteInput" />
        <div class="section-header">
          <input type="checkbox" id="checkDate" /><label for="dateInput"
            >Date</label
          >
        </div>
        <input type="text" id="dateInput" />
        <div class="master-check">
          <input type="checkbox" id="checkAllFields" /><label
            for="checkAllFields"
            >All sections and codes checked</label
          >
        </div>
        <span id="errorMsg" class="error"></span>
        <button type="button" id="addToQueueBtn">Add to Print Queue</button>
        <button type="button" id="downloadJsonBtn">Download JSON</button>
        <button type="button" id="cancelBtn">Cancel</button>
      </fieldset>
    </form>

    <fieldset id="printQueueSection">
      <legend>Print Queue</legend>
      <div id="queueControls">
        <button type="button" id="printAllQueuedBtn">Print All Queued</button>
        <label for="uploadJsonInput" class="button-like-label">
          Upload JSONs to Queue
        </label>
        <input type="file" id="uploadJsonInput" multiple accept=".json" />
        <button type="button" id="clearQueueBtn">Clear Queue</button>
      </div>
      <ul id="printQueueList"></ul>
      <p id="queueStatus">Queue is empty.</p>
    </fieldset>

    <script>
      const styleSheet = document.createElement("style");
      styleSheet.textContent = `
        #editForm { display: none; }
        #previewRaw { width: 100%; height: 100px; }
        #uploadJsonInput { display: none; }
      `;
      document.head.appendChild(styleSheet);

      const FONT_PATH_GLOBAL = "./NotoSans-Regular.ttf"; // Used by PDF and potentially non-PDF print
      const FONT_PATH_GLOBAL_BOLD = "./NotoSans-Bold.ttf"; // For bolder service names

      const sectionIds = [
        "checkService",
        "checkLogin",
        "checkNote",
        "checkDate",
      ];

      let pdfModeActive = true;

      function updateCodeMaster() {
        const codeChecks = document.querySelectorAll(".code-check");
        const masterCodes = document.getElementById("checkAllCodes");
        masterCodes.checked =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        updateFormMaster();
      }
      function updateFormMaster() {
        const sectionsOk = sectionIds.every(
          (id) => document.getElementById(id).checked
        );
        const codeChecks = document.querySelectorAll(".code-check");
        const codesOk =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        document.getElementById("checkAllFields").checked =
          sectionsOk && codesOk;
      }
      function bindSectionCheckboxes() {
        sectionIds.concat("checkAllCodes").forEach((id) => {
          document.getElementById(id).addEventListener("change", () => {
            if (id === "checkAllCodes") {
              const checked = document.getElementById("checkAllCodes").checked;
              document
                .querySelectorAll(".code-check")
                .forEach((c) => (c.checked = checked));
            }
            updateFormMaster();
          });
        });
      }
      function createCodeRow(val = "") {
        const div = document.createElement("div");
        div.className = "code-item";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.className = "code-check";
        const inp = document.createElement("input");
        inp.type = "text";
        inp.value = val;
        const del = document.createElement("button");
        del.type = "button";
        del.textContent = "✖";
        del.addEventListener("click", () => {
          div.remove();
          updateCodeMaster();
        });
        chk.addEventListener("change", updateCodeMaster);
        div.append(chk, inp, del);
        return div;
      }
      function addCode(val = "") {
        const row = createCodeRow(val);
        document.getElementById("codesContainer").appendChild(row);
        updateCodeMaster();
      }
      document
        .getElementById("addCodeBtn")
        .addEventListener("click", () => addCode(""));
      document
        .getElementById("checkAllFields")
        .addEventListener("change", (e) => {
          const checked = e.target.checked;
          sectionIds
            .concat("checkAllCodes")
            .forEach((id) => (document.getElementById(id).checked = checked));
          document
            .querySelectorAll(".code-check")
            .forEach((c) => (c.checked = checked));
        });
      const CODE_CANDIDATE_REGEX =
        /(?:(?<=^)|(?<=[^\p{L}\p{N}_]))(?:[\p{L}0-9]\p{M}*){4,}(?:[ -](?:[\p{L}0-9]\p{M}*){4,})*(?:(?=$)|(?=[^\p{L}\p{N}_]))/gu;
      const SPECIAL_CODE_WORDS = /^(?:UŻYTY|USED|JUŻ UŻYTY)$/i; // Case-insensitive, whole word

      function parseRaw(raw) {
        const lines = raw.split(/\r?\n/);
        let service = "",
          login = "",
          note = "",
          dateText = "",
          codes = [];
        let dateFoundInInput = false;

        lines.forEach((l) => {
          let originalTrimmedLine = l.trim();
          if (!originalTrimmedLine) return;

          let contentForDateCheck = originalTrimmedLine;
          if (/^[*\-]\s/.test(originalTrimmedLine)) {
            contentForDateCheck = originalTrimmedLine
              .replace(/^[*\-]\s*/, "")
              .trim();
          } else if (/^\d+\.\s/.test(originalTrimmedLine)) {
            contentForDateCheck = originalTrimmedLine
              .replace(/^\d+\.\s*/, "")
              .trim();
          }
          if (/\b(?:wygenerowano|generated)\s*:/i.test(contentForDateCheck)) {
            dateText = contentForDateCheck.split(/:(.+)/, 2)[1]?.trim() || "";
            dateFoundInInput = true;
            return;
          }

          let loginCandidateLine = originalTrimmedLine;
          loginCandidateLine = loginCandidateLine
            .replace(/^\d+\.[ \t]*/, "")
            .trim();
          loginCandidateLine = loginCandidateLine
            .replace(/^[*\-]\s*/, "")
            .trim();
          if (
            /^\S+@\S+\.\S+$/.test(loginCandidateLine) ||
            /^\(.+@.+\)$/.test(loginCandidateLine)
          ) {
            login = loginCandidateLine.replace(/^[()]+|[()]+$/g, "");
            return;
          }

          let contentForProcessing = originalTrimmedLine;
          const startsWithBullet = /^[*\-]\s/.test(originalTrimmedLine);
          const startsWithNumberList = /^\d+\.[ \t]/.test(originalTrimmedLine);

          if (startsWithBullet) {
            contentForProcessing = originalTrimmedLine
              .replace(/^[*\-]\s*/, "")
              .trim();
          } else if (startsWithNumberList) {
            contentForProcessing = originalTrimmedLine
              .replace(/^\d+\.[ \t]*/, "")
              .trim();
          }

          const potentialCodeTokens =
            contentForProcessing.match(CODE_CANDIDATE_REGEX);
          let actualCodesInLine = [];
          if (potentialCodeTokens) {
            actualCodesInLine = potentialCodeTokens.filter(
              (token) =>
                /\d/.test(token) || SPECIAL_CODE_WORDS.test(token.trim())
            );
          }

          if (actualCodesInLine.length > 0) {
            if (startsWithNumberList) {
              actualCodesInLine.forEach((tok) => {
                let codeToAdd = tok.trim();
                if (SPECIAL_CODE_WORDS.test(codeToAdd)) codeToAdd = "UŻYTY";
                codes.push(codeToAdd);
              });
              return;
            }

            let tempRemainder = contentForProcessing;
            actualCodesInLine.forEach((code) => {
              const codeRegex = new RegExp(
                `\\b${code.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`,
                "gi"
              );
              tempRemainder = tempRemainder.replace(codeRegex, "");
            });
            tempRemainder = tempRemainder.replace(/\b(?:JUŻ|ALREADY)\b/gi, ""); // Remove "JUŻ" etc.
            tempRemainder = tempRemainder.replace(/\d+\.\s*/g, "");
            tempRemainder = tempRemainder.trim().replace(/[.,;:!?]$/, "");

            if (tempRemainder.length === 0) {
              actualCodesInLine.forEach((tok) => {
                let codeToAdd = tok.trim();
                if (SPECIAL_CODE_WORDS.test(codeToAdd)) codeToAdd = "UŻYTY";
                codes.push(codeToAdd);
              });
              return;
            }
            if (
              startsWithBullet &&
              contentForProcessing.split(/\s+/).filter(Boolean).length <= 3 &&
              tempRemainder.length < contentForProcessing.length / 2
            ) {
              actualCodesInLine.forEach((tok) => {
                let codeToAdd = tok.trim();
                if (SPECIAL_CODE_WORDS.test(codeToAdd)) codeToAdd = "UŻYTY";
                codes.push(codeToAdd);
              });
              return;
            }
          }

          if (/^[*\-]\s/.test(originalTrimmedLine)) {
            note += contentForProcessing + " ";
            return;
          }

          if (!startsWithBullet && !startsWithNumberList) {
            if (
              !service &&
              contentForProcessing.length > 0 &&
              contentForProcessing.length < 70
            ) {
              if (
                contentForProcessing.split(/\s+/).filter(Boolean).length <= 5
              ) {
                service = contentForProcessing;
                return;
              }
            }
          }
        });

        if (!dateFoundInInput && !dateText) {
          dateText = new Date().toLocaleDateString();
        }
        return {
          service,
          login,
          note: note.trim(),
          date: dateText,
          codes,
          dateGenerated: !dateFoundInInput,
        };
      }
      document.getElementById("parseBtn").addEventListener("click", () => {
        const raw = document.getElementById("rawInput").value;
        const rawInputError = document.getElementById("rawInputError");

        if (!raw.trim()) {
          rawInputError.textContent = "Please paste the raw text.";
          rawInputError.style.display = "block";
          return;
        }
        rawInputError.textContent = "";
        rawInputError.style.display = "none";

        const data = parseRaw(raw);
        document.getElementById("previewRaw").value = raw;
        ["service", "login", "note", "date"].forEach(
          (f) => (document.getElementById(f + "Input").value = data[f])
        );
        document.getElementById("codesContainer").innerHTML = "";
        data.codes.forEach((c) => addCode(c));
        [
          "checkService",
          "checkLogin",
          "checkAllCodes",
          "checkNote",
          "checkDate",
          "checkAllFields",
        ].forEach((id) => (document.getElementById(id).checked = false));
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("errorMsg").style.display = "none";
        document.getElementById("rawSection").style.display = "none";
        document.getElementById("editForm").style.display = "block";
        bindSectionCheckboxes();
        updateCodeMaster();
      });
      document.getElementById("cancelBtn").addEventListener("click", () => {
        document.getElementById("editForm").style.display = "none";
        document.getElementById("rawSection").style.display = "block";
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("errorMsg").style.display = "none";
        document.getElementById("rawInputError").textContent = "";
        document.getElementById("rawInputError").style.display = "none";
      });

      let printQueue = [];

      function getCurrentFormData() {
        const err = document.getElementById("errorMsg");
        err.textContent = "";
        err.style.display = "none";
        if (!document.getElementById("checkAllFields").checked) {
          err.textContent =
            "Please confirm that all sections and codes have been checked.";
          err.style.display = "block";
          return null;
        }
        const srv = document.getElementById("serviceInput").value;
        const log = document.getElementById("loginInput").value;
        const notes = document.getElementById("noteInput").value;
        const dat = document.getElementById("dateInput").value;
        const items = Array.from(document.querySelectorAll(".code-item")).map(
          (d) => d.querySelector("input[type=text]").value
        );
        return {
          id: Date.now() + Math.random(),
          serviceName: srv,
          login: log,
          codes: items,
          note: notes,
          date: dat,
          originalRawInput: document.getElementById("previewRaw").value,
        };
      }

      function renderPrintQueue() {
        const queueList = document.getElementById("printQueueList");
        const queueStatus = document.getElementById("queueStatus");
        queueList.innerHTML = "";
        if (printQueue.length === 0) {
          queueStatus.style.display = "block";
          return;
        }
        queueStatus.style.display = "none";
        printQueue.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.serviceName || "Untitled"} (${
            item.codes.length
          } codes)`;
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "Remove";
          removeBtn.style.marginLeft = "10px";
          removeBtn.onclick = () => {
            printQueue = printQueue.filter((i) => i.id !== item.id);
            renderPrintQueue();
          };
          li.appendChild(removeBtn);
          queueList.appendChild(li);
        });
      }

      document.getElementById("addToQueueBtn").addEventListener("click", () => {
        const formData = getCurrentFormData();
        if (formData) {
          printQueue.push(formData);
          document.getElementById("errorMsg").style.display = "none";
          renderPrintQueue();
          alert(`"${formData.serviceName || "Item"}" added to print queue.`);
          document.getElementById("cancelBtn").click();
        }
      });

      document.getElementById("clearQueueBtn").addEventListener("click", () => {
        // prettier-ignore
        if (confirm("Are you sure you want to clear the entire print queue?")) {
          printQueue = [];
          renderPrintQueue();
        }
      });

      function generateBlockHtml(
        itemData,
        isFirstInPair = false,
        isPairOnPage = false
      ) {
        if (!itemData) return "";
        const codesHtml = itemData.codes
          .map((v) => `<li><input type="checkbox" disabled /> ${v}</li>`)
          .join("");
        const blockStyle =
          isFirstInPair && isPairOnPage ? 'style="margin-right: 5mm;"' : "";

        let html = `<div class="block" ${blockStyle}>`;
        if (itemData.serviceName) html += `<h2>${itemData.serviceName}</h2>`;
        if (itemData.login) html += `<p><strong>${itemData.login}</strong></p>`;
        if (itemData.date) html += `<p class="date">${itemData.date}</p>`; // Date now here
        if (itemData.codes && itemData.codes.length > 0)
          html += `<ul>${codesHtml}</ul>`;
        if (itemData.note) html += `<p><em>${itemData.note}</em></p>`; // Note is last
        html += `</div>`; // prettier-ignore
        return html;
      }

      document
        .getElementById("printAllQueuedBtn")
        .addEventListener("click", () => {
          if (printQueue.length === 0) {
            alert("Print queue is empty.");
            return;
          }

          if (pdfModeActive) {
            generateAndDownloadPdf();
            return;
          }

          let allBlocksHtml = "";
          for (let i = 0; i < printQueue.length; i += 2) {
            allBlocksHtml += `<div class="print-page-container">`;
            const item1 = printQueue[i];
            allBlocksHtml += generateBlockHtml(item1);
            if (i + 1 < printQueue.length) {
              const item2 = printQueue[i + 1];
              allBlocksHtml += generateBlockHtml(item2);
            }
            allBlocksHtml += `</div>`;
          }

          const win = window.open("", "_blank");
          const injectedScript = `
            async function printWhenReady() {
              try {
                await document.fonts.ready;
                window.print();
              } catch (error) {
                console.error('Error waiting for fonts, printing anyway:', error);
                window.print();
              }
            }
            window.onload = printWhenReady;
          `;
          win.document.write(
            `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Print Codes</title><style>
@font-face {
  font-family: 'NotoSansUnicode';
  src: url('${FONT_PATH_GLOBAL}') format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'NotoSansUnicode';
  src: url('${FONT_PATH_GLOBAL_BOLD}') format('truetype');
  font-weight: bold;
  font-style: normal;
}
body {
  margin: 0;
  background-color: #f0f0f0;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}
body { font-family: 'NotoSansUnicode', sans-serif; font-weight: normal; }
.print-page-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: flex-start;
  margin-bottom: 20px;
}
.block {
  width: 138mm;
  height: 190mm;
  box-sizing: border-box;
  border: 1px solid #444;
  margin: 5mm;
  padding: 10mm;
  font-size: 10pt;
  background-color: white;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  overflow: hidden;
  font-family: 'NotoSansUnicode', sans-serif; font-weight: normal;
}
.block h2 {
  font-family: 'NotoSansUnicode', sans-serif;
  font-weight: bold;
  font-size: 1.8em; margin-top: 0; margin-bottom: 0.6em; color: #333;
}
.block p { font-size: 1em; margin: 0.6em 0; line-height: 1.4; }
.block p strong { color: #000; font-weight: bold; }
.block ul { font-size: 1em; padding-left: 0; margin: 0.8em 0; list-style-type: none; }
.block li { margin-bottom: 0.5em; display: flex; align-items: center; }
.block li input[type="checkbox"] {
  width: 3mm;
  height: 3mm;
  margin-right: 1.5mm;
  flex-shrink: 0;
  vertical-align: middle;
  border: 1px solid #000;
  appearance: none;
  -webkit-appearance: none;
}
.block .date { font-size: 0.9em; color: #555; margin-top: 1em; text-align: left; }
.block em { color: #444; font-style: normal; }
.no-print { display: none; }

@media print {
  body { background-color: transparent; display: block; min-height: auto; margin:0; }
  .print-page-container {
    margin: 0;
    padding: 6mm;
    box-sizing: border-box;
    width: 297mm;
    display: flex;
    justify-content: flex-start;
    align-items: center;
    overflow: hidden;
  }
  .print-page-container:not(:first-of-type) {
    page-break-before: always;
  }
  .block {
    margin: 0;
    box-shadow: none;
    border: 1px solid #000;
    overflow: hidden;
  }
  .print-page-container > .block:first-child:not(:last-child) {
    margin-right: 5mm;
  }
}
</style></head><body>${allBlocksHtml}<script>${injectedScript}<\/script></body></html>`
          );
          win.document.close();
        });
      document
        .getElementById("downloadJsonBtn")
        .addEventListener("click", () => {
          const err = document.getElementById("errorMsg");
          err.textContent = "";
          err.style.display = "none";
          if (!document.getElementById("checkAllFields").checked) {
            err.textContent =
              "Please confirm that all sections and codes have been checked.";
            err.style.display = "block";
            return;
          }

          const srv = document.getElementById("serviceInput").value.trim();
          const log = document.getElementById("loginInput").value.trim();
          const notes = document.getElementById("noteInput").value.trim();
          const dat = document.getElementById("dateInput").value.trim();
          const items = Array.from(
            document.querySelectorAll(".code-item input[type=text]")
          ).map((input) => input.value.trim());

          const jsonData = {
            serviceName: srv,
            login: log,
            codes: items,
            note: notes,
            date: dat,
            originalRawInput: document.getElementById("previewRaw").value,
          };

          const jsonString = JSON.stringify(jsonData, null, 2);
          const blob = new Blob([jsonString], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${srv || "backup-codes"}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

      document
        .getElementById("uploadJsonInput")
        .addEventListener("change", function (event) {
          const files = event.target.files;
          if (!files.length) {
            return;
          }
          Array.from(files).forEach((file) => {
            const reader = new FileReader();
            reader.onload = function (e) {
              try {
                const jsonData = JSON.parse(e.target.result);
                if (
                  jsonData &&
                  typeof jsonData.serviceName !== "undefined" &&
                  Array.isArray(jsonData.codes)
                ) {
                  jsonData.id = Date.now() + Math.random();
                  printQueue.push(jsonData);
                  renderPrintQueue();
                } else {
                  alert(
                    `File "${file.name}" does not have the expected JSON structure.`
                  );
                }
              } catch (error) {
                alert(
                  `Error parsing JSON from file "${file.name}": ${error.message}`
                );
              }
            };
            reader.readAsText(file);
          });
          event.target.value = null;
        });

      async function generateAndDownloadPdf() {
        let base64FontRegular = await loadFontAsBase64(FONT_PATH_GLOBAL);
        let base64FontBold = await loadFontAsBase64(FONT_PATH_GLOBAL_BOLD);

        if (!base64FontRegular) {
          console.warn(
            "Proceeding with PDF generation without custom font. Non-English characters may not display correctly."
          );
        }

        if (printQueue.length === 0) {
          alert("Print queue is empty for PDF generation.");
          return;
        }

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: "l",
          unit: "mm",
          format: "a4",
        });

        const pdfFontName = "NotoSansUnicode";
        if (base64FontRegular) {
          pdf.addFileToVFS(
            FONT_PATH_GLOBAL.split("/").pop(),
            base64FontRegular
          );
          pdf.addFont(FONT_PATH_GLOBAL.split("/").pop(), pdfFontName, "normal");
        }
        if (base64FontBold) {
          pdf.addFileToVFS(
            FONT_PATH_GLOBAL_BOLD.split("/").pop(),
            base64FontBold
          );
          pdf.addFont(
            FONT_PATH_GLOBAL_BOLD.split("/").pop(),
            pdfFontName,
            "bold"
          );
        }

        pdf.setFont(pdfFontName, "normal");

        const PDF_PAGE_WIDTH = 297;
        const PDF_PAGE_HEIGHT = 210;
        const PDF_BLOCK_WIDTH = 138;
        const PDF_BLOCK_HEIGHT = 190;
        const PDF_INTER_BLOCK_MARGIN = 5;
        const PDF_BLOCK_PADDING = 12;

        const PDF_TITLE_FONT_SIZE_PT = 18;
        const PDF_LOGIN_FONT_SIZE_PT = 10;
        const PDF_CODES_FONT_SIZE_PT = 10;
        const PDF_NOTE_FONT_SIZE_PT = 10;
        const PDF_DATE_FONT_SIZE_PT = 9;

        const PT_TO_MM = 0.352778;
        const PDF_LINE_SPACING_FACTOR = 1.4;

        const PDF_TITLE_MARGIN_TOP_MM = 2;
        const MARGIN_COMMON_MM = 2.7;
        const MARGIN_CODES_LIST_MM = 2.8;
        const PDF_CODE_ITEM_MARGIN_BOTTOM_MM = 1.8;
        const PDF_CHECKBOX_SIZE_MM = 3;
        const PDF_CHECKBOX_TEXT_GAP_MM = 1.5;

        for (let i = 0; i < printQueue.length; i += 2) {
          if (i > 0) {
            pdf.addPage("a4", "l");
            if (base64FontRegular) {
              pdf.setFont(pdfFontName, "normal");
            } else {
            }
          }

          const itemsOnPage = [];
          if (printQueue[i]) itemsOnPage.push(printQueue[i]);
          if (i + 1 < printQueue.length) itemsOnPage.push(printQueue[i + 1]);

          const startXForAllBlocks =
            (PDF_PAGE_WIDTH - (PDF_BLOCK_WIDTH * 2 + PDF_INTER_BLOCK_MARGIN)) /
            2;
          const blockY = (PDF_PAGE_HEIGHT - PDF_BLOCK_HEIGHT) / 2;

          itemsOnPage.forEach((itemData, indexOnPage) => {
            if (!itemData) return;

            const itemX =
              startXForAllBlocks +
              indexOnPage * (PDF_BLOCK_WIDTH + PDF_INTER_BLOCK_MARGIN);
            let currentY = blockY + PDF_BLOCK_PADDING;

            pdf.setDrawColor(0);
            pdf.rect(itemX, blockY, PDF_BLOCK_WIDTH, PDF_BLOCK_HEIGHT);

            if (itemData.serviceName) {
              currentY += PDF_TITLE_MARGIN_TOP_MM;
              pdf.setFont(pdfFontName, "bold");
              pdf.setTextColor(51, 51, 51);
              pdf.setFontSize(PDF_TITLE_FONT_SIZE_PT);
              const titleMaxWidth = PDF_BLOCK_WIDTH - PDF_BLOCK_PADDING * 2;
              const titleText = String(itemData.serviceName);
              const titleLineHeightMm =
                PDF_TITLE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              pdf.text(titleText, itemX + PDF_BLOCK_PADDING, currentY, {
                maxWidth: titleMaxWidth,
              });
              currentY += titleLineHeightMm + MARGIN_COMMON_MM;
            }

            if (itemData.login) {
              pdf.setFont(pdfFontName, "bold");
              pdf.setTextColor(0, 0, 0);
              pdf.setFontSize(PDF_LOGIN_FONT_SIZE_PT);
              const loginText = String(itemData.login);
              const loginLineHeightMm =
                PDF_LOGIN_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              pdf.text(loginText, itemX + PDF_BLOCK_PADDING, currentY);
              currentY += loginLineHeightMm;
              currentY += MARGIN_COMMON_MM;
            }

            if (itemData.date) {
              pdf.setFont(pdfFontName, "normal");
              pdf.setTextColor(85, 85, 85); // #555
              pdf.setFontSize(PDF_DATE_FONT_SIZE_PT);
              const dateText = String(itemData.date);
              const dateLineHeightMm =
                PDF_DATE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              pdf.text(dateText, itemX + PDF_BLOCK_PADDING, currentY);
              currentY += dateLineHeightMm;
              currentY += MARGIN_COMMON_MM;
            }

            if (itemData.codes && itemData.codes.length > 0) {
              currentY += MARGIN_CODES_LIST_MM;
              pdf.setFont(pdfFontName, "normal");
              pdf.setTextColor(0, 0, 0);

              const codes = itemData.codes;
              const textMaxWidthForCode =
                PDF_BLOCK_WIDTH -
                PDF_BLOCK_PADDING * 2 -
                PDF_CHECKBOX_SIZE_MM -
                PDF_CHECKBOX_TEXT_GAP_MM;

              let localCodesContentHeight = 0;

              for (const code of codes) {
                if (!code) continue;
                pdf.setFontSize(PDF_CODES_FONT_SIZE_PT);
                const codeSingleLineHeightMm =
                  PDF_CODES_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
                const codeLines = pdf.splitTextToSize(
                  String(code),
                  textMaxWidthForCode
                );
                const thisCodeBlockHeight =
                  codeLines.length * codeSingleLineHeightMm +
                  PDF_CODE_ITEM_MARGIN_BOTTOM_MM;

                const estimatedNoteHeight = itemData.note
                  ? PDF_NOTE_FONT_SIZE_PT *
                      PT_TO_MM *
                      PDF_LINE_SPACING_FACTOR *
                      2 +
                    MARGIN_COMMON_MM +
                    MARGIN_COMMON_MM +
                    5
                  : 0;
                const maxCodesY =
                  blockY +
                  PDF_BLOCK_HEIGHT -
                  PDF_BLOCK_PADDING -
                  estimatedNoteHeight -
                  MARGIN_CODES_LIST_MM;

                if (
                  currentY + thisCodeBlockHeight > maxCodesY &&
                  localCodesContentHeight > 0
                ) {
                  break;
                }

                pdf.rect(
                  itemX + PDF_BLOCK_PADDING,
                  currentY - PDF_CHECKBOX_SIZE_MM * 0.75,
                  PDF_CHECKBOX_SIZE_MM,
                  PDF_CHECKBOX_SIZE_MM
                );

                let tempY = currentY;
                for (const line of codeLines) {
                  pdf.text(
                    String(line || ""),
                    itemX +
                      PDF_BLOCK_PADDING +
                      PDF_CHECKBOX_SIZE_MM +
                      PDF_CHECKBOX_TEXT_GAP_MM,
                    tempY
                  );
                  tempY += codeSingleLineHeightMm;
                }
                currentY += thisCodeBlockHeight;
                localCodesContentHeight += thisCodeBlockHeight;
              }

              if (localCodesContentHeight > 0) currentY += MARGIN_CODES_LIST_MM;
            }

            if (itemData.note) {
              currentY += MARGIN_COMMON_MM;
              pdf.setFont(pdfFontName, "normal");
              pdf.setTextColor(68, 68, 68); // #444
              pdf.setFontSize(PDF_NOTE_FONT_SIZE_PT);
              const noteSingleLineHeightMm =
                PDF_NOTE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              const noteLines = pdf.splitTextToSize(
                String(itemData.note),
                PDF_BLOCK_WIDTH - PDF_BLOCK_PADDING * 2
              );
              let noteContentHeight = 0;
              for (const line of noteLines) {
                if (
                  currentY + noteSingleLineHeightMm >
                  blockY +
                    PDF_BLOCK_HEIGHT -
                    PDF_BLOCK_PADDING -
                    MARGIN_COMMON_MM
                ) {
                  break;
                }
                pdf.text(
                  String(line || ""),
                  itemX + PDF_BLOCK_PADDING,
                  currentY
                );
                noteContentHeight += noteSingleLineHeightMm;
                currentY += noteSingleLineHeightMm;
              }
              if (noteContentHeight > 0) {
                currentY += MARGIN_COMMON_MM;
              }
            }
          });
        }
        pdf.save("backup-codes.pdf");
      }

      async function loadFontAsBase64(fontUrl) {
        try {
          const response = await fetch(fontUrl);
          if (!response.ok) {
            throw new Error(
              `Failed to load font: ${response.statusText} (URL: ${fontUrl})`
            );
          }
          const fontBuffer = await response.arrayBuffer();
          let binary = "";
          const bytes = new Uint8Array(fontBuffer);
          const len = bytes.byteLength;
          for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        } catch (error) {
          console.error(error);
          console.warn(
            `Error loading font from ${fontUrl}: ${error.message}. PDF might not render special characters correctly.`
          );
          return null;
        }
      }

      renderPrintQueue();

      const mainMenuBtn = document.getElementById("mainMenuBtn");
      const appMenuItems = document.getElementById("appMenuItems");
      const menuItemTestParser = document.getElementById("menuItemTestParser");
      const menuPdfModeCheckbox = document.getElementById(
        "menuPdfModeCheckbox"
      );

      menuPdfModeCheckbox.checked = pdfModeActive;
      menuPdfModeCheckbox.addEventListener("change", function (event) {
        pdfModeActive = event.target.checked;
      });

      mainMenuBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        const isMenuOpen = appMenuItems.style.display === "block";
        appMenuItems.style.display = isMenuOpen ? "none" : "block";
      });

      menuItemTestParser.addEventListener("click", async () => {
        appMenuItems.style.display = "none";
        await runParserTests();
      });

      // Click outside to close menu
      document.addEventListener("click", (event) => {
        if (
          appMenuItems.style.display === "block" &&
          !mainMenuBtn.contains(event.target) &&
          !appMenuItems.contains(event.target)
        ) {
          appMenuItems.style.display = "none";
        }
      });
      function areArraysEqual(arr1, arr2) {
        if (arr1 === arr2) return true;
        if (arr1 == null || arr2 == null) return false;
        if (!Array.isArray(arr1) || !Array.isArray(arr2)) return false;
        if (arr1.length !== arr2.length) return false;

        for (let i = 0; i < arr1.length; i++) {
          if (arr1[i] !== arr2[i]) return false;
        }
        return true;
      }

      async function runSingleParserTest(filePath) {
        try {
          const response = await fetch(filePath);
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const testData = await response.json();

          if (typeof testData.originalRawInput === "undefined") {
            throw new Error("Test JSON missing 'originalRawInput' field.");
          }

          const parsedOutput = parseRaw(testData.originalRawInput);

          const expected = {
            service: testData.serviceName,
            login: testData.login,
            codes: testData.codes,
            note: testData.note,
            date: testData.date,
          };

          const mismatches = [];

          if (parsedOutput.service !== expected.service) {
            mismatches.push(
              `  - Service: Expected "${expected.service}", Got "${parsedOutput.service}"`
            );
          }
          if (parsedOutput.login !== expected.login) {
            mismatches.push(
              `  - Login: Expected "${expected.login}", Got "${parsedOutput.login}"`
            );
          }
          if (!areArraysEqual(parsedOutput.codes, expected.codes)) {
            mismatches.push(
              `  - Codes: Expected ${JSON.stringify(
                expected.codes
              )}, Got ${JSON.stringify(parsedOutput.codes)}`
            );
          }
          if (parsedOutput.note !== expected.note) {
            // parseRaw trims note, so expected.note should be trimmed version
            mismatches.push(
              `  - Note: Expected "${expected.note}", Got "${parsedOutput.note}"`
            );
          }
          if (!parsedOutput.dateGenerated) {
            if (parsedOutput.date !== expected.date) {
              mismatches.push(`  - Date: Expected "${expected.date}", Got "${parsedOutput.date}"`); // prettier-ignore
            }
          } else {
            // If dateGenerated is true, we skip the date comparison as requested.
          }

          if (mismatches.length > 0) {
            return {
              fileName: filePath.split("/").pop(),
              status: "FAIL",
              details: mismatches.join("\n"),
            };
          } else {
            return { fileName: filePath.split("/").pop(), status: "PASS" };
          }
        } catch (error) {
          return {
            fileName: filePath.split("/").pop(),
            status: "ERROR",
            error: error.message,
          };
        }
      }

      async function runParserTests() {
        const testFiles = [
          "./tests/test1.json",
          "./tests/test2.json",
          "./tests/test3.json",
        ];
        let alertMessage = "Parser Test Results:\n\n";

        const results = await Promise.all(
          testFiles.map((file) => runSingleParserTest(file))
        );

        results.forEach((result) => {
          alertMessage += `Test File: ${result.fileName}\n`;
          alertMessage += `Status: ${result.status}\n`;
          if (result.status === "FAIL") {
            alertMessage += `Mismatched fields:\n${result.details}\n`;
          } else if (result.status === "ERROR") {
            alertMessage += `Error: ${result.error}\n`;
          }
          alertMessage += "\n";
        });
        if (testFiles.length === 0) {
          alertMessage = "No test files configured.";
        }
        alert(alertMessage);
      }
    </script>
  </body>
</html>
