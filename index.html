<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas is often used by jsPDF's html method, ensure it's available if complex rendering is needed -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link rel="icon" type="image/x-icon" href="backupcodesmanager.ico" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <title>Backup Codes Manager</title>
    <style>
      @font-face {
        font-family: "NotoSansUnicode";
        src: url("./NotoSans-Regular.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
      }
      @font-face {
        font-family: "NotoSansUnicode";
        src: url("./NotoSans-Bold.ttf") format("truetype"); /* Assuming you have a NotoSans-Bold.ttf */
        font-weight: bold;
        font-style: normal;
      }
      body {
        font-family: "NotoSansUnicode", sans-serif;
        margin: 20px;
      }
      textarea,
      input,
      button,
      fieldset {
        font-family: inherit; /* Inherit NotoSansUnicode from body */
      }
      textarea {
        width: 100%;
        height: 150px;
        margin-bottom: 10px;
      }
      fieldset {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ccc;
      }
      .section-header {
        display: flex;
        align-items: center;
        font-weight: bold;
        margin-top: 16px;
      }
      .section-header input[type="checkbox"] {
        margin-right: 8px;
      }
      input[type="text"] {
        width: 100%;
        padding: 5px;
        box-sizing: border-box;
        margin-bottom: 8px;
      }
      .codes-container {
        margin: 8px 0;
      }
      .code-item {
        display: flex;
        align-items: center;
        margin: 4px 0;
      }
      .code-item input[type="checkbox"] {
        margin-right: 8px;
      }
      .code-item input[type="text"] {
        flex: 1;
        padding: 4px;
        margin-right: 8px;
      }
      .code-item button {
        padding: 4px 8px;
      }
      #addCodeBtn {
        margin: 8px 0;
      }
      .master-check {
        display: flex;
        align-items: center;
        margin: 16px 0;
        font-weight: bold;
      }
      .master-check input[type="checkbox"] {
        margin-right: 8px;
      }
      button {
        padding: 8px 16px;
        margin-right: 10px;
        font-size: 1rem;
        cursor: pointer;
      }
      .error {
        color: red;
        margin-bottom: 12px;
        display: block;
      }
      .app-menu-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex; /* For aligning icon and text */
        align-items: center;
        font-size: 0.9em;
      }
      .app-menu-item:hover {
        background-color: #f0f0f0;
      }
      @media print {
        body {
          margin: 0;
        }
        .block {
          width: 105mm;
          height: 74mm;
          box-sizing: border-box;
          padding: 8mm;
          page-break-after: always;
        }
        .block input[type="checkbox"] {
          transform: scale(1.2);
          margin-right: 6px;
        }
      }
    </style>
  </head>
  <body>
    <h1>Backup 2FA Codes Manager</h1>

    <!-- New Menu Button and Pop-up Menu -->
    <div
      id="appMenuContainer"
      style="position: fixed; bottom: 20px; right: 20px; z-index: 1000"
    >
      <!-- Menu items, initially hidden, positioned above the button -->
      <div
        id="appMenuItems"
        style="
          display: none;
          position: absolute;
          bottom: 100%; /* Position above the button */
          right: 0; /* Align with the right of the button */
          margin-bottom: 8px; /* Space between menu and button */
          background: white;
          border: 1px solid #ccc;
          border-radius: 5px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
          padding: 5px 0;
          min-width: 160px; /* Ensure menu has some width */
        "
      >
        <div class="app-menu-item" id="menuItemTestParser">
          <span
            class="material-icons"
            style="font-size: 20px; vertical-align: middle; margin-right: 8px"
            >science</span
          >
          Test Parser
        </div>
        <div class="app-menu-item">
          <input
            type="checkbox"
            id="menuPdfModeCheckbox"
            style="margin-right: 8px; vertical-align: middle"
          />
          <label
            for="menuPdfModeCheckbox"
            style="vertical-align: middle; cursor: pointer"
            >PDF Mode</label
          >
        </div>
      </div>

      <!-- The actual menu button -->
      <button
        id="mainMenuBtn"
        title="Menu"
        style="
          cursor: pointer;
          padding: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          width: 38px; /* Same size as old test button */
          height: 38px; /* Same size as old test button */
          background: white;
          border: 1px solid #ccc;
          border-radius: 5px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        "
      >
        <span class="material-icons" style="font-size: 24px">menu</span>
      </button>
    </div>

    <div id="rawSection">
      <p>Paste the raw text with the list of backup codes:</p>
      <textarea id="rawInput" placeholder="Paste raw text..."></textarea>
      <span
        id="rawInputError"
        class="error"
        style="display: none; margin-bottom: 5px"
      ></span>
      <button id="parseBtn">Parse and Edit</button>
    </div>
    <form id="editForm" style="display: none">
      <fieldset>
        <legend>Original Text</legend>
        <textarea
          id="previewRaw"
          readonly
          style="width: 100%; height: 100px"
        ></textarea>
      </fieldset>
      <fieldset>
        <legend>Print Data</legend>
        <div class="section-header">
          <input type="checkbox" id="checkService" /><label for="serviceInput"
            >Service Name</label
          >
        </div>
        <input type="text" id="serviceInput" />
        <div class="section-header">
          <input type="checkbox" id="checkLogin" /><label for="loginInput"
            >Email/Login</label
          >
        </div>
        <input type="text" id="loginInput" />
        <div class="section-header">
          <input type="checkbox" id="checkAllCodes" /><label
            >List of Codes</label
          >
        </div>
        <div class="codes-container" id="codesContainer"></div>
        <button type="button" id="addCodeBtn">+ Add Code</button>
        <div class="section-header">
          <input type="checkbox" id="checkNote" /><label for="noteInput"
            >Note</label
          >
        </div>
        <input type="text" id="noteInput" />
        <div class="section-header">
          <input type="checkbox" id="checkDate" /><label for="dateInput"
            >Date</label
          >
        </div>
        <input type="text" id="dateInput" />
        <div class="master-check">
          <input type="checkbox" id="checkAllFields" /><label
            for="checkAllFields"
            >All sections and codes checked</label
          >
        </div>
        <span id="errorMsg" class="error"></span>
        <button type="button" id="addToQueueBtn">Add to Print Queue</button>
        <button type="button" id="downloadJsonBtn">Download JSON</button>
        <button type="button" id="cancelBtn">Cancel</button>
      </fieldset>
    </form>

    <fieldset id="printQueueSection">
      <legend>Print Queue</legend>
      <div id="queueControls">
        <label for="uploadJsonInput" class="button-like-label">
          Upload JSONs to Queue
        </label>
        <input
          type="file"
          id="uploadJsonInput"
          multiple
          accept=".json"
          style="display: none"
        />
        <button type="button" id="printAllQueuedBtn">Print All Queued</button>
        <button type="button" id="clearQueueBtn">Clear Queue</button>
      </div>
      <ul id="printQueueList">
        <!-- Queued items will be listed here -->
      </ul>
      <p id="queueStatus" style="display: none">Queue is empty.</p>
    </fieldset>

    <script>
      const FONT_PATH_GLOBAL = "./NotoSans-Regular.ttf"; // Used by PDF and potentially non-PDF print
      const FONT_PATH_GLOBAL_BOLD = "./NotoSans-Bold.ttf"; // For bolder service names

      const sectionIds = [
        "checkService",
        "checkLogin",
        "checkNote",
        "checkDate",
      ];

      let pdfModeActive = true; // Default to true
      // Style for the file input label to look like a button
      const style = document.createElement("style");
      style.innerHTML = `
        .button-like-label {
          padding: 8px 16px;
          margin-right: 10px;
          font-size: 1rem;
          cursor: pointer;
          background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; display: inline-block;
        }
        .button-like-label:hover { background-color: #e0e0e0; }
      `;
      document.head.appendChild(style);

      function updateCodeMaster() {
        const codeChecks = document.querySelectorAll(".code-check");
        const masterCodes = document.getElementById("checkAllCodes");
        masterCodes.checked =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        updateFormMaster();
      }
      function updateFormMaster() {
        const sectionsOk = sectionIds.every(
          (id) => document.getElementById(id).checked
        );
        const codeChecks = document.querySelectorAll(".code-check");
        const codesOk =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        document.getElementById("checkAllFields").checked =
          sectionsOk && codesOk;
      }
      function bindSectionCheckboxes() {
        sectionIds.concat("checkAllCodes").forEach((id) => {
          document.getElementById(id).addEventListener("change", () => {
            if (id === "checkAllCodes") {
              const checked = document.getElementById("checkAllCodes").checked;
              document
                .querySelectorAll(".code-check")
                .forEach((c) => (c.checked = checked));
            }
            updateFormMaster();
          });
        });
      }
      function createCodeRow(val = "") {
        const div = document.createElement("div");
        div.className = "code-item";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.className = "code-check";
        const inp = document.createElement("input");
        inp.type = "text";
        inp.value = val;
        const del = document.createElement("button");
        del.type = "button";
        del.textContent = "✖";
        del.addEventListener("click", () => {
          div.remove();
          updateCodeMaster();
        });
        chk.addEventListener("change", updateCodeMaster);
        div.append(chk, inp, del);
        return div;
      }
      function addCode(val = "") {
        const row = createCodeRow(val);
        document.getElementById("codesContainer").appendChild(row);
        updateCodeMaster();
      }
      document
        .getElementById("addCodeBtn")
        .addEventListener("click", () => addCode(""));
      document
        .getElementById("checkAllFields")
        .addEventListener("change", (e) => {
          const checked = e.target.checked;
          sectionIds
            .concat("checkAllCodes")
            .forEach((id) => (document.getElementById(id).checked = checked));
          document
            .querySelectorAll(".code-check")
            .forEach((c) => (c.checked = checked));
        });
      // Regex to find potential code candidates: alphanumeric sequences, 4+ chars,
      // possibly with internal hyphens or spaces. Does not require a digit at this stage.
      const CODE_CANDIDATE_REGEX =
        /(?:(?<=^)|(?<=[^\p{L}\p{N}_]))(?:[\p{L}0-9]\p{M}*){4,}(?:[ -](?:[\p{L}0-9]\p{M}*){4,})*(?:(?=$)|(?=[^\p{L}\p{N}_]))/gu;
      const SPECIAL_CODE_WORDS = /^(?:UŻYTY|USED|JUŻ UŻYTY)$/i; // Case-insensitive, whole word

      function parseRaw(raw) {
        const lines = raw.split(/\r?\n/);
        let service = "",
          login = "",
          note = "",
          dateText = "",
          codes = [];
        let dateFoundInInput = false;

        lines.forEach((l) => {
          let originalTrimmedLine = l.trim();
          if (!originalTrimmedLine) return;

          // 1. Date Check
          // Content for date check should be after stripping potential list markers.
          let contentForDateCheck = originalTrimmedLine;
          if (/^[*\-]\s/.test(originalTrimmedLine)) {
            contentForDateCheck = originalTrimmedLine
              .replace(/^[*\-]\s*/, "")
              .trim();
          } else if (/^\d+\.\s/.test(originalTrimmedLine)) {
            contentForDateCheck = originalTrimmedLine
              .replace(/^\d+\.\s*/, "")
              .trim();
          }
          if (/\b(?:wygenerowano|generated)\s*:/i.test(contentForDateCheck)) {
            dateText = contentForDateCheck.split(/:(.+)/, 2)[1]?.trim() || "";
            dateFoundInInput = true;
            return;
          }

          // 2. Login check (can also be prefixed, strip markers before checking)
          let loginCandidateLine = originalTrimmedLine;
          loginCandidateLine = loginCandidateLine
            .replace(/^\d+\.[ \t]*/, "")
            .trim(); // Strip "1. "
          loginCandidateLine = loginCandidateLine
            .replace(/^[*\-]\s*/, "")
            .trim(); // Strip "* " or "- "
          if (
            /^\S+@\S+\.\S+$/.test(loginCandidateLine) ||
            /^\(.+@.+\)$/.test(loginCandidateLine)
          ) {
            login = loginCandidateLine.replace(/^[()]+|[()]+$/g, "");
            return;
          }

          // For code, note, service:
          let contentForProcessing = originalTrimmedLine;
          const startsWithBullet = /^[*\-]\s/.test(originalTrimmedLine);
          const startsWithNumberList = /^\d+\.[ \t]/.test(originalTrimmedLine);

          if (startsWithBullet) {
            contentForProcessing = originalTrimmedLine
              .replace(/^[*\-]\s*/, "")
              .trim();
          } else if (startsWithNumberList) {
            contentForProcessing = originalTrimmedLine
              .replace(/^\d+\.[ \t]*/, "")
              .trim();
          }

          // 3. Code Detection
          const potentialCodeTokens =
            contentForProcessing.match(CODE_CANDIDATE_REGEX);
          let actualCodesInLine = [];
          if (potentialCodeTokens) {
            actualCodesInLine = potentialCodeTokens.filter(
              (token) =>
                /\d/.test(token) || SPECIAL_CODE_WORDS.test(token.trim())
            );
          }

          if (actualCodesInLine.length > 0) {
            if (startsWithNumberList) {
              // Numbered lists are strong indicators of codes
              actualCodesInLine.forEach((tok) => {
                let codeToAdd = tok.trim();
                if (SPECIAL_CODE_WORDS.test(codeToAdd)) codeToAdd = "UŻYTY";
                codes.push(codeToAdd);
              });
              return;
            }

            // For bulleted or non-prefixed lines, check if content is mostly codes
            let tempRemainder = contentForProcessing;
            actualCodesInLine.forEach((code) => {
              // Use a regex to replace the specific code as a whole word/unit, case-insensitively for removal
              const codeRegex = new RegExp(
                `\\b${code.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`,
                "gi"
              );
              tempRemainder = tempRemainder.replace(codeRegex, "");
            });
            tempRemainder = tempRemainder.replace(/\b(?:JUŻ|ALREADY)\b/gi, ""); // Remove "JUŻ" etc.
            tempRemainder = tempRemainder.replace(/\d+\.\s*/g, ""); // Remove "6. " type markers within content
            tempRemainder = tempRemainder.trim().replace(/[.,;:!?]$/, "");

            if (tempRemainder.length === 0) {
              // If what's left is empty, it was purely codes
              actualCodesInLine.forEach((tok) => {
                let codeToAdd = tok.trim();
                if (SPECIAL_CODE_WORDS.test(codeToAdd)) codeToAdd = "UŻYTY";
                codes.push(codeToAdd);
              });
              return;
            }
            // If bulleted and not purely codes, but still short (e.g. "* UŻYTY", "* code123")
            if (
              startsWithBullet &&
              contentForProcessing.split(/\s+/).filter(Boolean).length <= 3 &&
              tempRemainder.length < contentForProcessing.length / 2
            ) {
              actualCodesInLine.forEach((tok) => {
                let codeToAdd = tok.trim();
                if (SPECIAL_CODE_WORDS.test(codeToAdd)) codeToAdd = "UŻYTY";
                codes.push(codeToAdd);
              });
              return;
            }
          }

          // 4. Note Check (applies if it's a bulleted line not caught as codes or date)
          if (/^[*\-]\s/.test(originalTrimmedLine)) {
            // contentForProcessing is already the bullet's content
            note += contentForProcessing + " ";
            return;
          }

          // 5. Service Name Fallback
          if (!startsWithBullet && !startsWithNumberList) {
            if (
              !service &&
              contentForProcessing.length > 0 &&
              contentForProcessing.length < 70
            ) {
              if (
                contentForProcessing.split(/\s+/).filter(Boolean).length <= 5
              ) {
                service = contentForProcessing;
                return;
              }
            }
          }
        });

        if (!dateFoundInInput && !dateText) {
          // If no date was found from input and not set by other means
          dateText = new Date().toLocaleDateString();
        }
        return {
          service,
          login,
          note: note.trim(),
          date: dateText,
          codes,
          dateGenerated: !dateFoundInInput,
        };
      }
      document.getElementById("parseBtn").addEventListener("click", () => {
        const raw = document.getElementById("rawInput").value;
        const rawInputError = document.getElementById("rawInputError");

        if (!raw.trim()) {
          rawInputError.textContent = "Please paste the raw text.";
          rawInputError.style.display = "block";
          return;
        }
        rawInputError.textContent = "";
        rawInputError.style.display = "none";

        const data = parseRaw(raw);
        document.getElementById("previewRaw").value = raw;
        ["service", "login", "note", "date"].forEach(
          (f) => (document.getElementById(f + "Input").value = data[f])
        );
        document.getElementById("codesContainer").innerHTML = "";
        data.codes.forEach((c) => addCode(c));
        [
          "checkService",
          "checkLogin",
          "checkAllCodes",
          "checkNote",
          "checkDate",
          "checkAllFields",
        ].forEach((id) => (document.getElementById(id).checked = false));
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("rawSection").style.display = "none";
        document.getElementById("editForm").style.display = "block";
        bindSectionCheckboxes();
        updateCodeMaster();
      });
      document.getElementById("cancelBtn").addEventListener("click", () => {
        document.getElementById("editForm").style.display = "none";
        document.getElementById("rawSection").style.display = "block";
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("rawInputError").textContent = "";
        document.getElementById("rawInputError").style.display = "none";
      });

      let printQueue = [];

      function getCurrentFormData() {
        const err = document.getElementById("errorMsg");
        err.textContent = "";
        if (!document.getElementById("checkAllFields").checked) {
          err.textContent =
            "Please confirm that all sections and codes have been checked.";
          return null;
        }
        const srv = document.getElementById("serviceInput").value;
        const log = document.getElementById("loginInput").value;
        const notes = document.getElementById("noteInput").value;
        const dat = document.getElementById("dateInput").value;
        const items = Array.from(document.querySelectorAll(".code-item")).map(
          (d) => d.querySelector("input[type=text]").value
        );
        return {
          id: Date.now() + Math.random(), // Simple unique ID
          serviceName: srv,
          login: log,
          codes: items,
          note: notes,
          date: dat,
          originalRawInput: document.getElementById("previewRaw").value,
        };
      }

      function renderPrintQueue() {
        const queueList = document.getElementById("printQueueList");
        const queueStatus = document.getElementById("queueStatus");
        queueList.innerHTML = "";
        if (printQueue.length === 0) {
          queueStatus.style.display = "block";
          return;
        }
        queueStatus.style.display = "none";
        printQueue.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.serviceName || "Untitled"} (${
            item.codes.length
          } codes)`;
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "Remove";
          removeBtn.style.marginLeft = "10px";
          removeBtn.onclick = () => {
            printQueue = printQueue.filter((i) => i.id !== item.id);
            renderPrintQueue();
          };
          li.appendChild(removeBtn);
          queueList.appendChild(li);
        });
      }

      document.getElementById("addToQueueBtn").addEventListener("click", () => {
        const formData = getCurrentFormData();
        if (formData) {
          printQueue.push(formData);
          renderPrintQueue();
          alert(`"${formData.serviceName || "Item"}" added to print queue.`);
          // Optionally, reset the form or switch view
          document.getElementById("cancelBtn").click(); // Simulate cancel to reset view
        }
      });

      document.getElementById("clearQueueBtn").addEventListener("click", () => {
        if (confirm("Are you sure you want to clear the entire print queue?")) {
          printQueue = [];
          renderPrintQueue();
        }
      });

      // Hoist generateBlockHtml to be accessible by PDF generation logic
      function generateBlockHtml(
        itemData,
        isFirstInPair = false,
        isPairOnPage = false
      ) {
        if (!itemData) return "";
        const codesHtml = itemData.codes
          .map(
            (v) => `<li><input type="checkbox" disabled /> ${v}</li>` // Removed 'checked'
          ) // Self-closed for tidiness
          .join("");
        // Add margin-right to the first block only if it's part of a pair on the page
        const blockStyle =
          isFirstInPair && isPairOnPage ? 'style="margin-right: 5mm;"' : "";

        // New layout order for non-PDF (about:blank)
        let html = `<div class="block" ${blockStyle}>`;
        if (itemData.serviceName) html += `<h2>${itemData.serviceName}</h2>`;
        if (itemData.login) html += `<p><strong>${itemData.login}</strong></p>`;
        if (itemData.date) html += `<p class="date">${itemData.date}</p>`; // Date now here
        if (itemData.codes && itemData.codes.length > 0)
          html += `<ul>${codesHtml}</ul>`;
        if (itemData.note) html += `<p><em>${itemData.note}</em></p>`; // Note is last
        html += `</div>`;
        return html;
      }

      document
        .getElementById("printAllQueuedBtn")
        .addEventListener("click", () => {
          if (printQueue.length === 0) {
            alert("Print queue is empty.");
            return;
          }

          if (pdfModeActive) {
            generateAndDownloadPdf();
            return;
          }

          let allBlocksHtml = "";
          for (let i = 0; i < printQueue.length; i += 2) {
            allBlocksHtml += `<div class="print-page-container">`;
            const item1 = printQueue[i];
            allBlocksHtml += generateBlockHtml(item1);
            if (i + 1 < printQueue.length) {
              const item2 = printQueue[i + 1];
              allBlocksHtml += generateBlockHtml(item2);
            }
            allBlocksHtml += `</div>`;
          }

          const win = window.open("", "_blank");
          // Script to be injected into the new window.
          // It waits for fonts to be ready before printing.
          const injectedScript = `
            async function printWhenReady() {
              try {
                // Wait for all fonts specified in @font-face rules to be loaded and ready.
                await document.fonts.ready;
                // console.log('Fonts are ready, initiating print.');
                window.print();
              } catch (error) {
                console.error('Error waiting for fonts, printing anyway:', error);
                window.print(); // Fallback to print immediately if font check fails.
              }
            }

            // Call printWhenReady after the DOM is fully loaded.
            window.onload = printWhenReady;
          `;
          win.document.write(
            `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Print Codes</title><style>
@font-face {
  font-family: 'NotoSansUnicode';
  src: url('${FONT_PATH_GLOBAL}') format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'NotoSansUnicode';
  src: url('${FONT_PATH_GLOBAL_BOLD}') format('truetype');
  font-weight: bold;
  font-style: normal;
}
body {
  margin: 0;
  background-color: #f0f0f0; /* Preview background */
  display: flex; /* Center content in preview */
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}
body { font-family: 'NotoSansUnicode', sans-serif; font-weight: normal; } /* Apply Noto font to non-PDF print view */
.print-page-container { /* Container for one or two blocks in preview */
  display: flex;
  flex-direction: row;
  justify-content: center; /* Centers the block(s) within this container */
  align-items: flex-start;
  margin-bottom: 20px; /* Space between pairs in preview */
  /* Width will be determined by its content (one or two blocks with their margins) */
}
.block {
  width: 138mm; /* Reduced width to prevent overflow, matches PDF block width */
  height: 190mm; /* Approx. A5 landscape height, matches PDF block height */
  box-sizing: border-box;
  border: 1px solid #444;
  margin: 5mm; /* Spacing for preview */
  padding: 10mm;
  font-size: 10pt; /* Base font size for the block */
  background-color: white; /* White card background for preview */
  box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Subtle shadow for preview */
  overflow: hidden; /* Prevent content spill in preview */
  font-family: 'NotoSansUnicode', sans-serif; font-weight: normal; /* Ensure blocks also use Noto */
}
.block h2 {
  font-family: 'NotoSansUnicode', sans-serif; /* Explicitly set for h2 */
  font-weight: bold; /* Use the bold variant of NotoSansUnicode */
  font-size: 1.8em; margin-top: 0; margin-bottom: 0.6em; color: #333;
}
.block p { font-size: 1em; margin: 0.6em 0; line-height: 1.4; } /* line-height is 1.4 */
.block p strong { color: #000; font-weight: bold; } /* For login */
.block ul { font-size: 1em; padding-left: 0; margin: 0.8em 0; list-style-type: none; }
.block li { margin-bottom: 0.5em; display: flex; align-items: center; }
.block li input[type="checkbox"] {
  width: 3mm; /* Match PDF checkbox size */
  height: 3mm; /* Match PDF checkbox size */
  margin-right: 1.5mm; /* Match PDF checkbox text gap more closely */
  flex-shrink: 0;
  vertical-align: middle; /* Adjust for better alignment with text */
  border: 1px solid #000; /* Mimic PDF rect */
  appearance: none; /* Attempt to remove default styling */
  -webkit-appearance: none; /* For Safari/Chrome */
}
.block .date { font-size: 0.9em; color: #555; margin-top: 1em; text-align: left; } /* Align date to the left */
.block em { color: #444; font-style: normal; } /* For notes - remove italic */

/* Hide non-print elements if any were added to print window body */
.no-print { display: none; }

@media print { /* Styles for the main page's direct print, not the about:blank window */
  body { background-color: transparent; display: block; min-height: auto; margin:0; }
  .print-page-container {
    /* General styles for print-page-container */
    margin: 0; /* Reset preview margin */
    padding: 6mm; /* Overall page margin, similar to PDF's x_offset */
    box-sizing: border-box;
    width: 297mm; /* A4 landscape width */
    /* Let height be determined by content + padding, remove fixed height:
    height: 210mm; */
    display: flex;
    justify-content: flex-start; /* Align block(s) to the left of the padded area */
    align-items: center; /* Vertically center block(s) within the padded area */
    overflow: hidden; /* Prevent container itself from causing unexpected breaks */
  }
  /* Changed page break strategy: apply before instead of after */
  .print-page-container:not(:first-of-type) {
    page-break-before: always; /* Add page break before each container, except the first one */
  }
  .block {
    margin: 0; /* Reset preview margin, rely on container padding and flex gap */
    box-shadow: none;
    border: 1px solid #000; /* Match PDF border */
    /* width: 140mm and height: 190mm are already set */
    overflow: hidden; /* Good for print consistency */
  }
  /* Add margin to the first block if it's not the only block on the page */
  .print-page-container > .block:first-child:not(:last-child) {
    margin-right: 5mm; /* Space between the two blocks */
  }
}
</style></head><body>${allBlocksHtml}<script>${injectedScript}<\/script></body></html>`
          );
          win.document.close(); // Call close after writing content
        });
      document
        .getElementById("downloadJsonBtn")
        .addEventListener("click", () => {
          const err = document.getElementById("errorMsg");
          err.textContent = ""; // Clear previous errors
          if (!document.getElementById("checkAllFields").checked) {
            err.textContent =
              "Please confirm that all sections and codes have been checked.";
            return;
          }

          const srv = document.getElementById("serviceInput").value.trim();
          const log = document.getElementById("loginInput").value.trim();
          const notes = document.getElementById("noteInput").value.trim();
          const dat = document.getElementById("dateInput").value.trim();
          const items = Array.from(
            document.querySelectorAll(".code-item input[type=text]")
          ).map((input) => input.value.trim());

          const jsonData = {
            serviceName: srv,
            login: log,
            codes: items,
            note: notes,
            date: dat,
            originalRawInput: document.getElementById("previewRaw").value,
          };

          const jsonString = JSON.stringify(jsonData, null, 2); // null, 2 for pretty printing
          const blob = new Blob([jsonString], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${srv || "backup-codes"}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

      document
        .getElementById("uploadJsonInput")
        .addEventListener("change", function (event) {
          const files = event.target.files;
          if (!files.length) {
            return;
          }
          Array.from(files).forEach((file) => {
            const reader = new FileReader();
            reader.onload = function (e) {
              try {
                const jsonData = JSON.parse(e.target.result);
                // Basic validation for expected structure
                if (
                  jsonData &&
                  typeof jsonData.serviceName !== "undefined" &&
                  Array.isArray(jsonData.codes)
                ) {
                  jsonData.id = Date.now() + Math.random(); // Ensure unique ID
                  printQueue.push(jsonData);
                  renderPrintQueue();
                } else {
                  alert(
                    `File "${file.name}" does not have the expected JSON structure.`
                  );
                }
              } catch (error) {
                alert(
                  `Error parsing JSON from file "${file.name}": ${error.message}`
                );
              }
            };
            reader.readAsText(file);
          });
          // Reset file input to allow uploading the same file again if needed
          event.target.value = null;
        });

      async function generateAndDownloadPdf() {
        let base64FontRegular = await loadFontAsBase64(FONT_PATH_GLOBAL);
        let base64FontBold = await loadFontAsBase64(FONT_PATH_GLOBAL_BOLD);

        // --- End Font Embedding Logic ---

        if (!base64FontRegular) {
          // Check if the regular font failed to load
          // Alert is already shown in loadFontAsBase64 if it fails.
          // Decide if you want to proceed with default fonts or stop.
          // For now, we'll let it proceed, but characters might be wrong.
          console.warn(
            // Use console.warn for less intrusive message
            "Proceeding with PDF generation without custom font. Non-English characters may not display correctly."
          );
        }

        if (printQueue.length === 0) {
          alert("Print queue is empty for PDF generation.");
          return;
        }

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: "l", // landscape
          unit: "mm",
          format: "a4",
        });

        const pdfFontName = "NotoSansUnicode"; // Consistent font name
        // No need for pdfFontNameBold, jsPDF handles weights under the same family name

        if (base64FontRegular) {
          pdf.addFileToVFS(
            FONT_PATH_GLOBAL.split("/").pop(),
            base64FontRegular
          );
          pdf.addFont(FONT_PATH_GLOBAL.split("/").pop(), pdfFontName, "normal");
        }
        if (base64FontBold) {
          pdf.addFileToVFS(
            FONT_PATH_GLOBAL_BOLD.split("/").pop(),
            base64FontBold
          );
          pdf.addFont(
            FONT_PATH_GLOBAL_BOLD.split("/").pop(),
            pdfFontName,
            "bold"
          );
        }

        // Set default font for the PDF
        pdf.setFont(pdfFontName, "normal");

        // PDF Layout constants
        const PDF_PAGE_WIDTH = 297; // A4 landscape width in mm
        const PDF_PAGE_HEIGHT = 210; // A4 landscape height in mm
        const PDF_BLOCK_WIDTH = 138;
        const PDF_BLOCK_HEIGHT = 190;
        const PDF_INTER_BLOCK_MARGIN = 5; // mm
        const PDF_BLOCK_PADDING = 12; // Increased internal padding for content within a block (was 10)

        // Font sizes (Points) - to match non-PDF mode more closely
        const PDF_TITLE_FONT_SIZE_PT = 18;
        const PDF_LOGIN_FONT_SIZE_PT = 10;
        const PDF_CODES_FONT_SIZE_PT = 10;
        const PDF_NOTE_FONT_SIZE_PT = 10;
        const PDF_DATE_FONT_SIZE_PT = 9;

        // Line & Margin constants (mm)
        const PT_TO_MM = 0.352778;
        const PDF_LINE_SPACING_FACTOR = 1.4; // Match non-PDF CSS line-height

        const PDF_TITLE_MARGIN_TOP_MM = 2; // New: Extra top margin for service name
        // New margin model to mimic CSS more closely
        const MARGIN_COMMON_MM = 2.7; // Approx 0.75em of 10pt (for p, h2-bottom) - Increased from 2.2mm
        const MARGIN_CODES_LIST_MM = 2.8; // Approx 0.8em of 10pt (for ul top/bottom) - Reverted from 3.3mm

        const PDF_CODE_ITEM_MARGIN_BOTTOM_MM = 1.8; // Approx 0.5em of 10pt (li margin-bottom)
        // Individual list/item margins are still useful, but inter-block element spacing will be uniform.

        const PDF_CHECKBOX_SIZE_MM = 3;
        const PDF_CHECKBOX_TEXT_GAP_MM = 1.5;

        for (let i = 0; i < printQueue.length; i += 2) {
          if (i > 0) {
            pdf.addPage("a4", "l");
            // Re-apply default font on new page, jsPDF might reset it
            if (base64FontRegular) {
              // Check if regular font was loaded
              pdf.setFont(pdfFontName, "normal");
            } else {
              // Fallback if NotoSans-Regular wasn't loaded, jsPDF will use a default
            }
          }

          const itemsOnPage = [];
          if (printQueue[i]) itemsOnPage.push(printQueue[i]);
          if (i + 1 < printQueue.length) itemsOnPage.push(printQueue[i + 1]);

          // Calculate starting X position. If one item, it takes the left slot.
          const startXForAllBlocks =
            (PDF_PAGE_WIDTH - (PDF_BLOCK_WIDTH * 2 + PDF_INTER_BLOCK_MARGIN)) /
            2;
          const blockY = (PDF_PAGE_HEIGHT - PDF_BLOCK_HEIGHT) / 2;

          itemsOnPage.forEach((itemData, indexOnPage) => {
            if (!itemData) return;

            const itemX =
              startXForAllBlocks +
              indexOnPage * (PDF_BLOCK_WIDTH + PDF_INTER_BLOCK_MARGIN);
            let currentY = blockY + PDF_BLOCK_PADDING; // Start Y inside padding

            // Draw block border
            pdf.setDrawColor(0); // Black
            pdf.rect(itemX, blockY, PDF_BLOCK_WIDTH, PDF_BLOCK_HEIGHT);

            // Service Name
            if (itemData.serviceName) {
              currentY += PDF_TITLE_MARGIN_TOP_MM; // Apply specific top margin for title
              pdf.setFont(pdfFontName, "bold");
              pdf.setTextColor(51, 51, 51); // #333
              pdf.setFontSize(PDF_TITLE_FONT_SIZE_PT);
              const titleMaxWidth = PDF_BLOCK_WIDTH - PDF_BLOCK_PADDING * 2; // Available width for title
              const titleText = String(itemData.serviceName);
              const titleLineHeightMm =
                PDF_TITLE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              pdf.text(titleText, itemX + PDF_BLOCK_PADDING, currentY, {
                maxWidth: titleMaxWidth,
              });
              currentY += titleLineHeightMm + MARGIN_COMMON_MM; // h2.marginBottom
            }

            // Login
            if (itemData.login) {
              // No explicit top margin needed if using consistent PDF_ELEMENT_SPACING_MM from previous element
              pdf.setFont(pdfFontName, "bold");
              pdf.setTextColor(0, 0, 0);
              pdf.setFontSize(PDF_LOGIN_FONT_SIZE_PT);
              const loginText = String(itemData.login);
              const loginLineHeightMm =
                PDF_LOGIN_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              pdf.text(loginText, itemX + PDF_BLOCK_PADDING, currentY);
              currentY += loginLineHeightMm; // Advance past text
              currentY += MARGIN_COMMON_MM; // p.marginBottom
            }

            // Date - New Position
            if (itemData.date) {
              // No explicit top margin needed
              pdf.setFont(pdfFontName, "normal");
              pdf.setTextColor(85, 85, 85); // #555
              pdf.setFontSize(PDF_DATE_FONT_SIZE_PT);
              const dateText = String(itemData.date);
              const dateLineHeightMm =
                PDF_DATE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              pdf.text(dateText, itemX + PDF_BLOCK_PADDING, currentY);
              currentY += dateLineHeightMm; // Advance past text
              currentY += MARGIN_COMMON_MM; // p.marginBottom
            }

            // Codes
            if (itemData.codes && itemData.codes.length > 0) {
              currentY += MARGIN_CODES_LIST_MM; // ul.marginTop
              pdf.setFont(pdfFontName, "normal");
              pdf.setTextColor(0, 0, 0);

              const codes = itemData.codes;
              const textMaxWidthForCode =
                PDF_BLOCK_WIDTH -
                PDF_BLOCK_PADDING * 2 -
                PDF_CHECKBOX_SIZE_MM -
                PDF_CHECKBOX_TEXT_GAP_MM;

              let localCodesContentHeight = 0; // To track height of codes items for overflow check

              for (const code of codes) {
                if (!code) continue; // Skip empty/null codes
                pdf.setFontSize(PDF_CODES_FONT_SIZE_PT);
                const codeSingleLineHeightMm =
                  PDF_CODES_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
                const codeLines = pdf.splitTextToSize(
                  String(code),
                  textMaxWidthForCode
                );
                const thisCodeBlockHeight =
                  codeLines.length * codeSingleLineHeightMm +
                  PDF_CODE_ITEM_MARGIN_BOTTOM_MM;

                const estimatedNoteHeight = itemData.note
                  ? PDF_NOTE_FONT_SIZE_PT *
                      PT_TO_MM *
                      PDF_LINE_SPACING_FACTOR *
                      2 + // Estimate 2 lines of note
                    MARGIN_COMMON_MM + // Note's p.marginTop
                    MARGIN_COMMON_MM + // Note's p.marginBottom
                    5 // Buffer
                  : 0;
                const maxCodesY =
                  blockY +
                  PDF_BLOCK_HEIGHT -
                  PDF_BLOCK_PADDING -
                  estimatedNoteHeight -
                  MARGIN_CODES_LIST_MM; // Space for codes list's own ul.marginBottom

                if (
                  currentY + thisCodeBlockHeight > maxCodesY && // currentY is where this code item STARTS
                  localCodesContentHeight > 0 // Only break if at least one code was already drawn
                ) {
                  break;
                }

                pdf.rect(
                  itemX + PDF_BLOCK_PADDING,
                  currentY - PDF_CHECKBOX_SIZE_MM * 0.75,
                  PDF_CHECKBOX_SIZE_MM,
                  PDF_CHECKBOX_SIZE_MM
                );

                let tempY = currentY;
                for (const line of codeLines) {
                  pdf.text(
                    String(line || ""),
                    itemX +
                      PDF_BLOCK_PADDING +
                      PDF_CHECKBOX_SIZE_MM +
                      PDF_CHECKBOX_TEXT_GAP_MM,
                    tempY
                  );
                  tempY += codeSingleLineHeightMm;
                }
                currentY += thisCodeBlockHeight;
                localCodesContentHeight += thisCodeBlockHeight;
              }

              // After the loop, currentY is at the end of all drawn code items (including their internal bottom margins).
              // Now add the codes list's (ul) bottom margin.
              if (localCodesContentHeight > 0) currentY += MARGIN_CODES_LIST_MM; // ul.marginBottom
            }

            // Note (if exists, position towards bottom)
            if (itemData.note) {
              currentY += MARGIN_COMMON_MM; // Note's p.marginTop
              pdf.setFont(pdfFontName, "normal");
              pdf.setTextColor(68, 68, 68); // #444
              pdf.setFontSize(PDF_NOTE_FONT_SIZE_PT);
              const noteSingleLineHeightMm =
                PDF_NOTE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              const noteLines = pdf.splitTextToSize(
                String(itemData.note),
                PDF_BLOCK_WIDTH - PDF_BLOCK_PADDING * 2
              );
              let noteContentHeight = 0;
              for (const line of noteLines) {
                if (
                  currentY + noteSingleLineHeightMm >
                  blockY +
                    PDF_BLOCK_HEIGHT -
                    PDF_BLOCK_PADDING -
                    MARGIN_COMMON_MM // Ensure note text + its p.marginBottom fits
                ) {
                  break;
                }
                pdf.text(
                  String(line || ""),
                  itemX + PDF_BLOCK_PADDING,
                  currentY
                );
                noteContentHeight += noteSingleLineHeightMm;
                currentY += noteSingleLineHeightMm; // Advance Y for each line of the note
              }
              if (noteContentHeight > 0) {
                // currentY is already past the note text.
                // Add the note's (p) bottom margin.
                currentY += MARGIN_COMMON_MM;
              }
            }
          });
        }
        pdf.save("backup-codes.pdf");
      }

      async function loadFontAsBase64(fontUrl) {
        try {
          const response = await fetch(fontUrl);
          if (!response.ok) {
            throw new Error(
              `Failed to load font: ${response.statusText} (URL: ${fontUrl})`
            );
          }
          const fontBuffer = await response.arrayBuffer();
          let binary = "";
          const bytes = new Uint8Array(fontBuffer);
          const len = bytes.byteLength;
          for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        } catch (error) {
          console.error(error);
          console.warn(
            `Error loading font from ${fontUrl}: ${error.message}. PDF might not render special characters correctly.`
          );
          return null;
        }
      }

      renderPrintQueue();

      // --- New Menu Logic ---
      const mainMenuBtn = document.getElementById("mainMenuBtn");
      const appMenuItems = document.getElementById("appMenuItems");
      const menuItemTestParser = document.getElementById("menuItemTestParser");
      const menuPdfModeCheckbox = document.getElementById(
        "menuPdfModeCheckbox"
      );

      // Initialize PDF Mode from the menu checkbox
      // pdfModeActive is already defined and defaulted to true earlier
      menuPdfModeCheckbox.checked = pdfModeActive;
      menuPdfModeCheckbox.addEventListener("change", function (event) {
        pdfModeActive = event.target.checked;
      });

      mainMenuBtn.addEventListener("click", (event) => {
        event.stopPropagation(); // Prevent click from immediately closing menu if body listener is active
        const isMenuOpen = appMenuItems.style.display === "block";
        appMenuItems.style.display = isMenuOpen ? "none" : "block";
      });

      // Test Parser functionality (triggered from menu)
      menuItemTestParser.addEventListener("click", async () => {
        appMenuItems.style.display = "none"; // Hide menu after click
        await runParserTests(); // Call the refactored function
      });

      // Click outside to close menu
      document.addEventListener("click", (event) => {
        if (
          appMenuItems.style.display === "block" &&
          !mainMenuBtn.contains(event.target) &&
          !appMenuItems.contains(event.target)
        ) {
          appMenuItems.style.display = "none";
        }
      });
      // --- End New Menu Logic ---

      // Ensure the old standalone PDF mode checkbox (if any element with that ID still exists by mistake)
      // does not interfere. The new one is menuPdfModeCheckbox.
      // const oldPdfCheckbox = document.getElementById("pdfModeCheckbox");
      // if (oldPdfCheckbox && oldPdfCheckbox !== menuPdfModeCheckbox) {
      //   oldPdfCheckbox.removeEventListener("change", ...); // Or ensure it's removed from HTML
      // }
      // --- Parser Test Logic ---
      function areArraysEqual(arr1, arr2) {
        if (arr1 === arr2) return true;
        if (arr1 == null || arr2 == null) return false;
        if (!Array.isArray(arr1) || !Array.isArray(arr2)) return false;
        if (arr1.length !== arr2.length) return false;

        for (let i = 0; i < arr1.length; i++) {
          if (arr1[i] !== arr2[i]) return false;
        }
        return true;
      }

      async function runSingleParserTest(filePath) {
        try {
          const response = await fetch(filePath);
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const testData = await response.json();

          if (typeof testData.originalRawInput === "undefined") {
            throw new Error("Test JSON missing 'originalRawInput' field.");
          }

          const parsedOutput = parseRaw(testData.originalRawInput);

          const expected = {
            service: testData.serviceName,
            login: testData.login,
            codes: testData.codes,
            note: testData.note,
            date: testData.date,
          };

          const mismatches = [];

          if (parsedOutput.service !== expected.service) {
            mismatches.push(
              `  - Service: Expected "${expected.service}", Got "${parsedOutput.service}"`
            );
          }
          if (parsedOutput.login !== expected.login) {
            mismatches.push(
              `  - Login: Expected "${expected.login}", Got "${parsedOutput.login}"`
            );
          }
          if (!areArraysEqual(parsedOutput.codes, expected.codes)) {
            mismatches.push(
              `  - Codes: Expected ${JSON.stringify(
                expected.codes
              )}, Got ${JSON.stringify(parsedOutput.codes)}`
            );
          }
          if (parsedOutput.note !== expected.note) {
            // parseRaw trims note, so expected.note should be trimmed version
            mismatches.push(
              `  - Note: Expected "${expected.note}", Got "${parsedOutput.note}"`
            );
          }
          // Only test the date if it was NOT artificially generated by parseRaw
          if (!parsedOutput.dateGenerated) {
            if (parsedOutput.date !== expected.date) {
              mismatches.push(
                `  - Date: Expected "${expected.date}", Got "${parsedOutput.date}"`
              );
            }
          } else {
            // If dateGenerated is true, we skip the date comparison as requested.
          }

          if (mismatches.length > 0) {
            return {
              fileName: filePath.split("/").pop(),
              status: "FAIL",
              details: mismatches.join("\n"),
            };
          } else {
            return { fileName: filePath.split("/").pop(), status: "PASS" };
          }
        } catch (error) {
          return {
            fileName: filePath.split("/").pop(),
            status: "ERROR",
            error: error.message,
          };
        }
      }

      // Refactored function to run parser tests
      async function runParserTests() {
        const testFiles = [
          "./tests/test1.json",
          "./tests/test2.json",
          "./tests/test3.json",
        ];
        let alertMessage = "Parser Test Results:\n\n";

        const results = await Promise.all(
          testFiles.map((file) => runSingleParserTest(file))
        );

        results.forEach((result) => {
          alertMessage += `Test File: ${result.fileName}\n`;
          alertMessage += `Status: ${result.status}\n`;
          if (result.status === "FAIL") {
            alertMessage += `Mismatched fields:\n${result.details}\n`;
          } else if (result.status === "ERROR") {
            alertMessage += `Error: ${result.error}\n`;
          }
          alertMessage += "\n";
        });
        if (testFiles.length === 0) {
          alertMessage = "No test files configured.";
        }
        alert(alertMessage);
      }
    </script>
  </body>
</html>
