<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas is often used by jsPDF's html method, ensure it's available if complex rendering is needed -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <title>Backup Codes Manager</title>
    <style>
      @font-face {
        font-family: "NotoSansUnicode";
        src: url("./NotoSans-Regular.ttf") format("truetype");
      }
      body {
        font-family: "NotoSansUnicode", sans-serif;
        margin: 20px;
      }
      textarea,
      input,
      button,
      fieldset {
        font-family: inherit; /* Inherit NotoSansUnicode from body */
      }
      textarea {
        width: 100%;
        height: 150px;
        margin-bottom: 10px;
      }
      fieldset {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ccc;
      }
      .section-header {
        display: flex;
        align-items: center;
        font-weight: bold;
        margin-top: 16px;
      }
      .section-header input[type="checkbox"] {
        margin-right: 8px;
      }
      input[type="text"] {
        width: 100%;
        padding: 5px;
        box-sizing: border-box;
        margin-bottom: 8px;
      }
      .codes-container {
        margin: 8px 0;
      }
      .code-item {
        display: flex;
        align-items: center;
        margin: 4px 0;
      }
      .code-item input[type="checkbox"] {
        margin-right: 8px;
      }
      .code-item input[type="text"] {
        flex: 1;
        padding: 4px;
        margin-right: 8px;
      }
      .code-item button {
        padding: 4px 8px;
      }
      #addCodeBtn {
        margin: 8px 0;
      }
      .master-check {
        display: flex;
        align-items: center;
        margin: 16px 0;
        font-weight: bold;
      }
      .master-check input[type="checkbox"] {
        margin-right: 8px;
      }
      button {
        padding: 8px 16px;
        margin-right: 10px;
        font-size: 1rem;
        cursor: pointer;
      }
      .error {
        color: red;
        margin-bottom: 12px;
        display: block;
      }
      @media print {
        body {
          margin: 0;
        }
        .block {
          width: 105mm;
          height: 74mm;
          box-sizing: border-box;
          padding: 8mm;
          page-break-after: always;
        }
        .block input[type="checkbox"] {
          transform: scale(1.2);
          margin-right: 6px;
        }
      }
    </style>
  </head>
  <body>
    <h1>Backup 2FA Codes Manager</h1>
    <div
      id="pdfModeToggleContainer"
      style="
        position: fixed;
        top: 10px;
        right: 20px;
        z-index: 1000;
        background: white;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      "
    >
      <label for="pdfModeCheckbox" style="margin-right: 5px; font-size: 0.9em"
        >PDF Mode:</label
      >
      <input
        type="checkbox"
        id="pdfModeCheckbox"
        style="vertical-align: middle"
      />
    </div>

    <div id="rawSection">
      <p>Paste the raw text with the list of backup codes:</p>
      <textarea id="rawInput" placeholder="Paste raw text..."></textarea>
      <span
        id="rawInputError"
        class="error"
        style="display: none; margin-bottom: 5px"
      ></span>
      <button id="parseBtn">Parse and Edit</button>
    </div>
    <form id="editForm" style="display: none">
      <fieldset>
        <legend>Original Text</legend>
        <textarea
          id="previewRaw"
          readonly
          style="width: 100%; height: 100px"
        ></textarea>
      </fieldset>
      <fieldset>
        <legend>Print Data</legend>
        <div class="section-header">
          <input type="checkbox" id="checkService" /><label for="serviceInput"
            >Service Name</label
          >
        </div>
        <input type="text" id="serviceInput" />
        <div class="section-header">
          <input type="checkbox" id="checkLogin" /><label for="loginInput"
            >Email/Login</label
          >
        </div>
        <input type="text" id="loginInput" />
        <div class="section-header">
          <input type="checkbox" id="checkAllCodes" /><label
            >List of Codes</label
          >
        </div>
        <div class="codes-container" id="codesContainer"></div>
        <button type="button" id="addCodeBtn">+ Add Code</button>
        <div class="section-header">
          <input type="checkbox" id="checkNote" /><label for="noteInput"
            >Note</label
          >
        </div>
        <input type="text" id="noteInput" />
        <div class="section-header">
          <input type="checkbox" id="checkDate" /><label for="dateInput"
            >Date</label
          >
        </div>
        <input type="text" id="dateInput" />
        <div class="master-check">
          <input type="checkbox" id="checkAllFields" /><label
            for="checkAllFields"
            >All sections and codes checked</label
          >
        </div>
        <span id="errorMsg" class="error"></span>
        <button type="button" id="addToQueueBtn">Add to Print Queue</button>
        <button type="button" id="downloadJsonBtn">Download JSON</button>
        <button type="button" id="cancelBtn">Cancel</button>
      </fieldset>
    </form>

    <fieldset id="printQueueSection">
      <legend>Print Queue</legend>
      <div id="queueControls">
        <label for="uploadJsonInput" class="button-like-label">
          Upload JSONs to Queue
        </label>
        <input
          type="file"
          id="uploadJsonInput"
          multiple
          accept=".json"
          style="display: none"
        />
        <button type="button" id="printAllQueuedBtn">Print All Queued</button>
        <button type="button" id="clearQueueBtn">Clear Queue</button>
      </div>
      <ul id="printQueueList">
        <!-- Queued items will be listed here -->
      </ul>
      <p id="queueStatus" style="display: none">Queue is empty.</p>
    </fieldset>

    <script>
      const FONT_PATH_GLOBAL = "./NotoSans-Regular.ttf"; // Used by PDF and potentially non-PDF print

      const sectionIds = [
        "checkService",
        "checkLogin",
        "checkNote",
        "checkDate",
      ];

      let pdfModeActive = false;
      document
        .getElementById("pdfModeCheckbox")
        .addEventListener("change", function (event) {
          pdfModeActive = event.target.checked;
        });

      // Style for the file input label to look like a button
      const style = document.createElement("style");
      style.innerHTML = `
        .button-like-label {
          padding: 8px 16px;
          margin-right: 10px;
          font-size: 1rem;
          cursor: pointer;
          background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; display: inline-block;
        }
        .button-like-label:hover { background-color: #e0e0e0; }
      `;
      document.head.appendChild(style);

      function updateCodeMaster() {
        const codeChecks = document.querySelectorAll(".code-check");
        const masterCodes = document.getElementById("checkAllCodes");
        masterCodes.checked =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        updateFormMaster();
      }
      function updateFormMaster() {
        const sectionsOk = sectionIds.every(
          (id) => document.getElementById(id).checked
        );
        const codeChecks = document.querySelectorAll(".code-check");
        const codesOk =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        document.getElementById("checkAllFields").checked =
          sectionsOk && codesOk;
      }
      function bindSectionCheckboxes() {
        sectionIds.concat("checkAllCodes").forEach((id) => {
          document.getElementById(id).addEventListener("change", () => {
            if (id === "checkAllCodes") {
              const checked = document.getElementById("checkAllCodes").checked;
              document
                .querySelectorAll(".code-check")
                .forEach((c) => (c.checked = checked));
            }
            updateFormMaster();
          });
        });
      }
      function createCodeRow(val = "") {
        const div = document.createElement("div");
        div.className = "code-item";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.className = "code-check";
        const inp = document.createElement("input");
        inp.type = "text";
        inp.value = val;
        const del = document.createElement("button");
        del.type = "button";
        del.textContent = "✖";
        del.addEventListener("click", () => {
          div.remove();
          updateCodeMaster();
        });
        chk.addEventListener("change", updateCodeMaster);
        div.append(chk, inp, del);
        return div;
      }
      function addCode(val = "") {
        const row = createCodeRow(val);
        document.getElementById("codesContainer").appendChild(row);
        updateCodeMaster();
      }
      document
        .getElementById("addCodeBtn")
        .addEventListener("click", () => addCode(""));
      document
        .getElementById("checkAllFields")
        .addEventListener("change", (e) => {
          const checked = e.target.checked;
          sectionIds
            .concat("checkAllCodes")
            .forEach((id) => (document.getElementById(id).checked = checked));
          document
            .querySelectorAll(".code-check")
            .forEach((c) => (c.checked = checked));
        });
      // Regex to find codes: alphanumeric with at least one digit, supporting Unicode letters (diacritics).
      // Handles precomposed and decomposed Unicode characters (e.g., letter + combining marks).
      // Using lookarounds for boundaries due to potential \b issues with some Unicode sequences.
      const CODE_REGEX =
        /(?:(?<=^)|(?<=[^\p{L}\p{N}_]))(?=.*\d)(?:[\p{L}0-9]\p{M}*){4,}(?:[ -](?:[\p{L}0-9]\p{M}*){4,})*(?:(?=$)|(?=[^\p{L}\p{N}_]))/gu;
      function parseRaw(raw) {
        const lines = raw.split(/\r?\n/);
        let service = "",
          login = "",
          note = "",
          dateText = "",
          codes = [];
        lines.forEach((l) => {
          let t = l.trim();
          if (!t) return;
          t = t.replace(/^\d+\.[ \t]*/, "").trim();
          if (/\b(?:wygenerowano|generated)[:]?/i.test(t)) {
            dateText = t.split(/[:]/).slice(1).join(":").trim();
            return;
          }
          if (/^\S+@\S+\.\S+$/.test(t) || /^\(.+@.+\)$/.test(t)) {
            login = t.replace(/^[()]+|[()]+$/g, "");
            return;
          }
          if (/^[*\-]\s/.test(t)) {
            note += t.replace(/^[*\-]\s*/, "") + " ";
            return;
          }
          const found = t.match(CODE_REGEX);
          if (found) {
            found.forEach((tok) => codes.push(tok.trim()));
            return;
          }
          if (!service && t.length < 50) {
            service = t;
          }
        });
        if (!dateText) dateText = new Date().toLocaleDateString();
        return { service, login, note: note.trim(), date: dateText, codes };
      }
      document.getElementById("parseBtn").addEventListener("click", () => {
        const raw = document.getElementById("rawInput").value;
        const rawInputError = document.getElementById("rawInputError");

        if (!raw.trim()) {
          rawInputError.textContent = "Please paste the raw text.";
          rawInputError.style.display = "block";
          return;
        }
        rawInputError.textContent = "";
        rawInputError.style.display = "none";

        const data = parseRaw(raw);
        document.getElementById("previewRaw").value = raw;
        ["service", "login", "note", "date"].forEach(
          (f) => (document.getElementById(f + "Input").value = data[f])
        );
        document.getElementById("codesContainer").innerHTML = "";
        data.codes.forEach((c) => addCode(c));
        [
          "checkService",
          "checkLogin",
          "checkAllCodes",
          "checkNote",
          "checkDate",
          "checkAllFields",
        ].forEach((id) => (document.getElementById(id).checked = false));
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("rawSection").style.display = "none";
        document.getElementById("editForm").style.display = "block";
        bindSectionCheckboxes();
        updateCodeMaster();
      });
      document.getElementById("cancelBtn").addEventListener("click", () => {
        document.getElementById("editForm").style.display = "none";
        document.getElementById("rawSection").style.display = "block";
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("rawInputError").textContent = "";
        document.getElementById("rawInputError").style.display = "none";
      });

      let printQueue = [];

      function getCurrentFormData() {
        const err = document.getElementById("errorMsg");
        err.textContent = "";
        if (!document.getElementById("checkAllFields").checked) {
          err.textContent =
            "Please confirm that all sections and codes have been checked.";
          return null;
        }
        const srv = document.getElementById("serviceInput").value;
        const log = document.getElementById("loginInput").value;
        const notes = document.getElementById("noteInput").value;
        const dat = document.getElementById("dateInput").value;
        const items = Array.from(document.querySelectorAll(".code-item")).map(
          (d) => d.querySelector("input[type=text]").value
        );
        return {
          id: Date.now() + Math.random(), // Simple unique ID
          serviceName: srv,
          login: log,
          codes: items,
          note: notes,
          date: dat,
          originalRawInput: document.getElementById("previewRaw").value,
        };
      }

      function renderPrintQueue() {
        const queueList = document.getElementById("printQueueList");
        const queueStatus = document.getElementById("queueStatus");
        queueList.innerHTML = "";
        if (printQueue.length === 0) {
          queueStatus.style.display = "block";
          return;
        }
        queueStatus.style.display = "none";
        printQueue.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.serviceName || "Untitled"} (${
            item.codes.length
          } codes)`;
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "Remove";
          removeBtn.style.marginLeft = "10px";
          removeBtn.onclick = () => {
            printQueue = printQueue.filter((i) => i.id !== item.id);
            renderPrintQueue();
          };
          li.appendChild(removeBtn);
          queueList.appendChild(li);
        });
      }

      document.getElementById("addToQueueBtn").addEventListener("click", () => {
        const formData = getCurrentFormData();
        if (formData) {
          printQueue.push(formData);
          renderPrintQueue();
          alert(`"${formData.serviceName || "Item"}" added to print queue.`);
          // Optionally, reset the form or switch view
          document.getElementById("cancelBtn").click(); // Simulate cancel to reset view
        }
      });

      document.getElementById("clearQueueBtn").addEventListener("click", () => {
        if (confirm("Are you sure you want to clear the entire print queue?")) {
          printQueue = [];
          renderPrintQueue();
        }
      });

      // Hoist generateBlockHtml to be accessible by PDF generation logic
      function generateBlockHtml(
        itemData,
        isFirstInPair = false,
        isPairOnPage = false
      ) {
        if (!itemData) return "";
        const codesHtml = itemData.codes
          .map(
            (v) => `<li><input type="checkbox" disabled checked /> ${v}</li>`
          ) // Self-closed for tidiness
          .join("");
        // Add margin-right to the first block only if it's part of a pair on the page
        const blockStyle =
          isFirstInPair && isPairOnPage ? 'style="margin-right: 5mm;"' : "";

        return `<div class="block" ${blockStyle}><h2>${
          itemData.serviceName
        }</h2><p><strong>${itemData.login}</strong></p><ul>${codesHtml}</ul>${
          itemData.note ? `<p><em>${itemData.note}</em></p>` : ""
        }<p class="date">${itemData.date}</p></div>`;
      }

      document
        .getElementById("printAllQueuedBtn")
        .addEventListener("click", () => {
          if (printQueue.length === 0) {
            alert("Print queue is empty.");
            return;
          }

          if (pdfModeActive) {
            generateAndDownloadPdf();
            return;
          }

          let allBlocksHtml = "";
          for (let i = 0; i < printQueue.length; i += 2) {
            allBlocksHtml += `<div class="print-page-container">`;
            const item1 = printQueue[i];
            allBlocksHtml += generateBlockHtml(item1);
            if (i + 1 < printQueue.length) {
              const item2 = printQueue[i + 1];
              allBlocksHtml += generateBlockHtml(item2);
            }
            allBlocksHtml += `</div>`;
          }

          const win = window.open("", "_blank");
          win.document.write(
            `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Print Codes</title><style>
@font-face { font-family: 'NotoSansUnicode'; src: url('${FONT_PATH_GLOBAL}') format('truetype'); } body {
  font-family: sans-serif;
  margin: 0;
  background-color: #f0f0f0; /* Preview background */
  display: flex; /* Center content in preview */
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}
body { font-family: 'NotoSansUnicode', sans-serif; } /* Apply Noto font to non-PDF print view */
.print-page-container { /* Container for one or two blocks in preview */
  display: flex;
  flex-direction: row;
  justify-content: center; /* Centers the block(s) within this container */
  align-items: flex-start;
  margin-bottom: 20px; /* Space between pairs in preview */
  /* Width will be determined by its content (one or two blocks with their margins) */
}
.block {
  width: 138mm; /* Reduced width to prevent overflow, matches PDF block width */
  height: 190mm; /* Approx. A5 landscape height, matches PDF block height */
  box-sizing: border-box;
  border: 1px solid #444;
  margin: 5mm; /* Spacing for preview */
  padding: 10mm;
  font-size: 10pt; /* Base font size for the block */
  background-color: white; /* White card background for preview */
  box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Subtle shadow for preview */
  overflow: hidden; /* Prevent content spill in preview */
  font-family: 'NotoSansUnicode', sans-serif; /* Ensure blocks also use Noto */
}
.block h2 { font-size: 1.8em; margin-top: 0; margin-bottom: 0.6em; color: #333; font-weight: bold;}
.block p { font-size: 1em; margin: 0.6em 0; line-height: 1.4; }
.block p strong { color: #000; font-weight: bold; } /* For login */
.block ul { font-size: 1em; padding-left: 0; margin: 0.8em 0; list-style-type: none; }
.block li { margin-bottom: 0.5em; display: flex; align-items: center; }
.block li input[type="checkbox"] { transform: scale(1.3); margin-right: 10px; flex-shrink: 0; }
.block .date { font-size: 0.9em; color: #555; margin-top: 1em; text-align: right; }
.block em { color: #444; font-style: italic; } /* For notes */

/* Hide non-print elements if any were added to print window body */
.no-print { display: none; }

@media print {
  body { background-color: transparent; display: block; min-height: auto; margin:0; }
  .print-page-container {
    /* General styles for print-page-container */
    margin: 0; /* Reset preview margin */
    padding: 6mm; /* Overall page margin, similar to PDF's x_offset */
    box-sizing: border-box;
    width: 297mm; /* A4 landscape width */
    /* Let height be determined by content + padding, remove fixed height:
    height: 210mm; */
    display: flex;
    justify-content: flex-start; /* Align block(s) to the left of the padded area */
    align-items: center; /* Vertically center block(s) within the padded area */
    overflow: hidden; /* Prevent container itself from causing unexpected breaks */
  }
  /* Changed page break strategy: apply before instead of after */
  .print-page-container:not(:first-of-type) {
    page-break-before: always; /* Add page break before each container, except the first one */
  }
  .block {
    margin: 0; /* Reset preview margin, rely on container padding and flex gap */
    box-shadow: none;
    border: 1px solid #000; /* Match PDF border */
    /* width: 140mm and height: 190mm are already set */
    overflow: hidden; /* Good for print consistency */
  }
  /* Add margin to the first block if it's not the only block on the page */
  .print-page-container > .block:first-child:not(:last-child) {
    margin-right: 5mm; /* Space between the two blocks */
  }
}
</style></head><body>${allBlocksHtml}<script>window.print()<\/script></body></html>`
          );
        });
      document
        .getElementById("downloadJsonBtn")
        .addEventListener("click", () => {
          const srv = document.getElementById("serviceInput").value.trim();
          const log = document.getElementById("loginInput").value.trim();
          const notes = document.getElementById("noteInput").value.trim();
          const dat = document.getElementById("dateInput").value.trim();
          const items = Array.from(
            document.querySelectorAll(".code-item input[type=text]")
          ).map((input) => input.value.trim());

          const jsonData = {
            serviceName: srv,
            login: log,
            codes: items,
            note: notes,
            date: dat,
            originalRawInput: document.getElementById("previewRaw").value,
          };

          const jsonString = JSON.stringify(jsonData, null, 2); // null, 2 for pretty printing
          const blob = new Blob([jsonString], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${srv || "backup-codes"}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

      document
        .getElementById("uploadJsonInput")
        .addEventListener("change", function (event) {
          const files = event.target.files;
          if (!files.length) {
            return;
          }
          Array.from(files).forEach((file) => {
            const reader = new FileReader();
            reader.onload = function (e) {
              try {
                const jsonData = JSON.parse(e.target.result);
                // Basic validation for expected structure
                if (
                  jsonData &&
                  typeof jsonData.serviceName !== "undefined" &&
                  Array.isArray(jsonData.codes)
                ) {
                  jsonData.id = Date.now() + Math.random(); // Ensure unique ID
                  printQueue.push(jsonData);
                  renderPrintQueue();
                } else {
                  alert(
                    `File "${file.name}" does not have the expected JSON structure.`
                  );
                }
              } catch (error) {
                alert(
                  `Error parsing JSON from file "${file.name}": ${error.message}`
                );
              }
            };
            reader.readAsText(file);
          });
          // Reset file input to allow uploading the same file again if needed
          event.target.value = null;
        });

      async function generateAndDownloadPdf() {
        // --- Font Embedding Logic ---
        // const fontPath = "./NotoSans-Regular.ttf"; // Path to the font file - now using FONT_PATH_GLOBAL
        const pdfFontName = "NotoSansUnicode"; // A name for jsPDF and CSS

        let base64Font = await loadFontAsBase64(FONT_PATH_GLOBAL);

        // --- End Font Embedding Logic ---

        if (!base64Font) {
          // Alert is already shown in loadFontAsBase64 if it fails.
          // Decide if you want to proceed with default fonts or stop.
          // For now, we'll let it proceed, but characters might be wrong.
          alert(
            "Proceeding with PDF generation without custom font. Non-English characters may not display correctly."
          );
        }

        if (printQueue.length === 0) {
          alert("Print queue is empty for PDF generation.");
          return;
        }

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: "l", // landscape
          unit: "mm",
          format: "a4",
        });

        if (base64Font) {
          pdf.addFileToVFS(FONT_PATH_GLOBAL.split("/").pop(), base64Font); // e.g., 'NotoSans-Regular.ttf'
          pdf.addFont(FONT_PATH_GLOBAL.split("/").pop(), pdfFontName, "normal");
          pdf.setFont(pdfFontName); // Set this font as active for jsPDF
        }

        // CSS for PDF rendering. This needs to be carefully crafted.
        const printCSS = `
          @font-face { font-family: '${pdfFontName}'; src: url('${FONT_PATH_GLOBAL}'); } /* Helps html2canvas find the font */
          body { font-family: '${pdfFontName}', sans-serif; margin: 0; } /* Apply Noto to body for PDF rendering context */
          .print-page-container-for-pdf { /* This container will be dynamically sized */
            display: flex;
            justify-content: flex-start; /* Blocks align to the left within this container */
            /* width and height will be set via JS to fit content tightly */
            box-sizing: border-box; /* No padding here; offsets will handle page margins */
            overflow: hidden;
          }
          .block {
            font-family: '${
              base64Font ? pdfFontName : "sans-serif"
            }'; /* Use embedded font, fallback to sans-serif */
            width: 138mm;  /* Consistent width */
            height: 190mm; /* Consistent height, was 188mm, changed for consistency */
            box-sizing: border-box;
            border: 1px solid #000;
            /* margin-right is now handled by generateBlockHtml for the first block in a pair */
            padding: 10mm;
            font-size: 10pt; /* Base font size */
            background-color: white;
            overflow: hidden;
            color: #000; /* Ensure text is black */
          }
          .block:last-child { margin-right: 0; }
          .block h2 { font-size: 1.8em; margin-top: 0; margin-bottom: 0.6em; color: #000; font-weight: bold;}
          .block p { font-size: 1em; margin: 0.6em 0; line-height: 1.4; color: #000;}
          .block p strong { color: #000; font-weight: bold; }
          .block ul { font-size: 1em; padding-left: 0; margin: 0.8em 0; list-style-type: none; color: #000;}
          .block li { margin-bottom: 0.5em; display: flex; align-items: center; color: #000;}
          .block li input[type="checkbox"] { /* Basic visual representation for PDF */
            display: inline-block; width: 3mm; height: 3mm; margin-right: 3mm;
            border: 0.5mm solid #000; background-color: #fff; vertical-align: middle;
            position: relative; /* For pseudo-element checkmark */
          }
          .block li input[type="checkbox"]:checked::before { /* Simple checkmark */
            content: '✔';
            position: absolute;
            top: -0.5mm; left: 0.5mm;
            font-size: 3mm;
            color: #000;
          }
          .block .date { font-size: 0.9em; color: #333; margin-top: 1em; text-align: right; }
          .block em { color: #333; font-style: italic; }
        `;

        const styleElement = document.createElement("style");
        styleElement.id = "tempPrintStylesForPdf";
        styleElement.type = "text/css";
        styleElement.appendChild(document.createTextNode(printCSS));
        document.head.appendChild(styleElement);

        const pdfPageWidth = 297; // A4 landscape width in mm
        const pdfPageHeight = 210; // A4 landscape height in mm
        const blockNominalHeight = 190; // mm - Updated to match CSS (was 188mm)
        const blockNominalWidth = 138; // mm - Updated to match CSS
        const interBlockMargin = 5; // mm
        const scaleFactor = 96 / 25.4; // Approx pixels per mm for html2canvas windowWidth/Height

        for (let i = 0; i < printQueue.length; i += 2) {
          // Create a new temporary div for each page's content to ensure isolation
          const pageSpecificTempRenderDiv = document.createElement("div");
          Object.assign(pageSpecificTempRenderDiv.style, {
            position: "absolute",
            left: "-3500px", // Ensure it's far off-screen
            top: "-3500px",
            width: "auto", // Will be set by content
            height: "auto", // Will be set by content
            // visibility: "hidden", // Rely on off-screen positioning
          });
          document.body.appendChild(pageSpecificTempRenderDiv);

          // If it's not the very first page, add a new page before rendering content
          if (i > 0) {
            pdf.addPage("a4", "l");
            if (base64Font) {
              pdf.setFont(pdfFontName);
            } // Closes if (base64Font)
          } // Closes if (i > 0)
          let pageHtml = `<div class="print-page-container-for-pdf">`; // This will be the content of pageSpecificTempRenderDiv
          let blocksOnThisPage = 0;
          let currentPageContentWidth = 0;

          // First block for the current page
          if (printQueue[i]) {
            blocksOnThisPage++;
            currentPageContentWidth += blockNominalWidth;
            const isPairOnThisPage = i + 1 < printQueue.length; // Will there be a second block on this page?
            pageHtml += generateBlockHtml(
              printQueue[i],
              true,
              isPairOnThisPage
            );
          }

          // Second block for the current page, if it exists in the queue
          if (i + 1 < printQueue.length) {
            blocksOnThisPage++;
            currentPageContentWidth += interBlockMargin + blockNominalWidth; // Add margin only if two blocks
            pageHtml += generateBlockHtml(printQueue[i + 1], false, true); // Second block is never "firstInPair", always part of a pair if it exists
          }
          pageHtml += `</div>`;

          pageSpecificTempRenderDiv.innerHTML = pageHtml;
          const containerElement = pageSpecificTempRenderDiv.firstChild; // Get the actual container we just created

          // Dynamically set the container's dimensions to tightly wrap its content
          containerElement.style.width = `${currentPageContentWidth}mm`;
          containerElement.style.height = `${blockNominalHeight}mm`;

          // Calculate the consistent X offset for the content area
          // This margin is based on fitting two blocks and their interconnecting margin.
          const x_offset =
            (pdfPageWidth - (blockNominalWidth * 2 + interBlockMargin)) / 2;
          const y_offset = (pdfPageHeight - blockNominalHeight) / 2;

          // Use html2canvas directly to render the element to a canvas
          const canvas = await html2canvas(containerElement, {
            scale: 2, // Increase scale for better resolution in PDF. Adjust as needed.
            useCORS: true, // Good practice, though font is local via @font-face
            logging: false, // Suppress html2canvas console logs
            backgroundColor: null, // Ensures transparency if parts of the element are transparent
          });
          const imgData = canvas.toDataURL("image/png");

          // Add the generated image to the PDF
          // Note: addImage uses the current page. If pdfCurrentPageNum > 1, addPage() should have been called.
          // pdf.setPage(pdfPageCounter); // addPage makes the new page active, setPage is not needed here
          pdf.addImage(
            imgData,
            "PNG",
            // Use the calculated offsets and dimensions
            x_offset,
            y_offset,
            currentPageContentWidth,
            blockNominalHeight
          );

          document.body.removeChild(pageSpecificTempRenderDiv); // Clean up this page's specific temporary div
        }

        document.head.removeChild(styleElement);
        pdf.save("backup-codes.pdf");
      }

      async function loadFontAsBase64(fontUrl) {
        try {
          const response = await fetch(fontUrl);
          if (!response.ok) {
            throw new Error(
              `Failed to load font: ${response.statusText} (URL: ${fontUrl})`
            );
          }
          const fontBuffer = await response.arrayBuffer();
          let binary = "";
          const bytes = new Uint8Array(fontBuffer);
          const len = bytes.byteLength;
          for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        } catch (error) {
          console.error(error);
          alert(
            `Error loading font from ${fontUrl}: ${error.message}. PDF might not render special characters correctly.`
          );
          return null; // Return null if font loading fails
        }
      }

      renderPrintQueue(); // Initial render of the queue (will show empty message)
    </script>
  </body>
</html>
