<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas is often used by jsPDF's html method, ensure it's available if complex rendering is needed -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <title>Backup Codes Manager</title>
    <style>
      @font-face {
        font-family: "NotoSansUnicode";
        src: url("./NotoSans-Regular.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
      }
      @font-face {
        font-family: "NotoSansUnicode";
        src: url("./NotoSans-Bold.ttf") format("truetype"); /* Assuming you have a NotoSans-Bold.ttf */
        font-weight: bold;
        font-style: normal;
      }
      body {
        font-family: "NotoSansUnicode", sans-serif;
        margin: 20px;
      }
      textarea,
      input,
      button,
      fieldset {
        font-family: inherit; /* Inherit NotoSansUnicode from body */
      }
      textarea {
        width: 100%;
        height: 150px;
        margin-bottom: 10px;
      }
      fieldset {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ccc;
      }
      .section-header {
        display: flex;
        align-items: center;
        font-weight: bold;
        margin-top: 16px;
      }
      .section-header input[type="checkbox"] {
        margin-right: 8px;
      }
      input[type="text"] {
        width: 100%;
        padding: 5px;
        box-sizing: border-box;
        margin-bottom: 8px;
      }
      .codes-container {
        margin: 8px 0;
      }
      .code-item {
        display: flex;
        align-items: center;
        margin: 4px 0;
      }
      .code-item input[type="checkbox"] {
        margin-right: 8px;
      }
      .code-item input[type="text"] {
        flex: 1;
        padding: 4px;
        margin-right: 8px;
      }
      .code-item button {
        padding: 4px 8px;
      }
      #addCodeBtn {
        margin: 8px 0;
      }
      .master-check {
        display: flex;
        align-items: center;
        margin: 16px 0;
        font-weight: bold;
      }
      .master-check input[type="checkbox"] {
        margin-right: 8px;
      }
      button {
        padding: 8px 16px;
        margin-right: 10px;
        font-size: 1rem;
        cursor: pointer;
      }
      .error {
        color: red;
        margin-bottom: 12px;
        display: block;
      }
      @media print {
        body {
          margin: 0;
        }
        .block {
          width: 105mm;
          height: 74mm;
          box-sizing: border-box;
          padding: 8mm;
          page-break-after: always;
        }
        .block input[type="checkbox"] {
          transform: scale(1.2);
          margin-right: 6px;
        }
      }
    </style>
  </head>
  <body>
    <h1>Backup 2FA Codes Manager</h1>
    <div
      id="pdfModeToggleContainer"
      style="
        position: fixed;
        top: 10px;
        right: 20px;
        z-index: 1000;
        background: white;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      "
    >
      <label for="pdfModeCheckbox" style="margin-right: 5px; font-size: 0.9em"
        >PDF Mode:</label
      >
      <input
        type="checkbox"
        id="pdfModeCheckbox"
        style="vertical-align: middle"
      />
    </div>

    <div id="rawSection">
      <p>Paste the raw text with the list of backup codes:</p>
      <textarea id="rawInput" placeholder="Paste raw text..."></textarea>
      <span
        id="rawInputError"
        class="error"
        style="display: none; margin-bottom: 5px"
      ></span>
      <button id="parseBtn">Parse and Edit</button>
    </div>
    <form id="editForm" style="display: none">
      <fieldset>
        <legend>Original Text</legend>
        <textarea
          id="previewRaw"
          readonly
          style="width: 100%; height: 100px"
        ></textarea>
      </fieldset>
      <fieldset>
        <legend>Print Data</legend>
        <div class="section-header">
          <input type="checkbox" id="checkService" /><label for="serviceInput"
            >Service Name</label
          >
        </div>
        <input type="text" id="serviceInput" />
        <div class="section-header">
          <input type="checkbox" id="checkLogin" /><label for="loginInput"
            >Email/Login</label
          >
        </div>
        <input type="text" id="loginInput" />
        <div class="section-header">
          <input type="checkbox" id="checkAllCodes" /><label
            >List of Codes</label
          >
        </div>
        <div class="codes-container" id="codesContainer"></div>
        <button type="button" id="addCodeBtn">+ Add Code</button>
        <div class="section-header">
          <input type="checkbox" id="checkNote" /><label for="noteInput"
            >Note</label
          >
        </div>
        <input type="text" id="noteInput" />
        <div class="section-header">
          <input type="checkbox" id="checkDate" /><label for="dateInput"
            >Date</label
          >
        </div>
        <input type="text" id="dateInput" />
        <div class="master-check">
          <input type="checkbox" id="checkAllFields" /><label
            for="checkAllFields"
            >All sections and codes checked</label
          >
        </div>
        <span id="errorMsg" class="error"></span>
        <button type="button" id="addToQueueBtn">Add to Print Queue</button>
        <button type="button" id="downloadJsonBtn">Download JSON</button>
        <button type="button" id="cancelBtn">Cancel</button>
      </fieldset>
    </form>

    <fieldset id="printQueueSection">
      <legend>Print Queue</legend>
      <div id="queueControls">
        <label for="uploadJsonInput" class="button-like-label">
          Upload JSONs to Queue
        </label>
        <input
          type="file"
          id="uploadJsonInput"
          multiple
          accept=".json"
          style="display: none"
        />
        <button type="button" id="printAllQueuedBtn">Print All Queued</button>
        <button type="button" id="clearQueueBtn">Clear Queue</button>
      </div>
      <ul id="printQueueList">
        <!-- Queued items will be listed here -->
      </ul>
      <p id="queueStatus" style="display: none">Queue is empty.</p>
    </fieldset>

    <script>
      const FONT_PATH_GLOBAL = "./NotoSans-Regular.ttf"; // Used by PDF and potentially non-PDF print
      const FONT_PATH_GLOBAL_BOLD = "./NotoSans-Bold.ttf"; // For bolder service names

      const sectionIds = [
        "checkService",
        "checkLogin",
        "checkNote",
        "checkDate",
      ];

      let pdfModeActive = false;
      document
        .getElementById("pdfModeCheckbox")
        .addEventListener("change", function (event) {
          pdfModeActive = event.target.checked;
        });

      // Style for the file input label to look like a button
      const style = document.createElement("style");
      style.innerHTML = `
        .button-like-label {
          padding: 8px 16px;
          margin-right: 10px;
          font-size: 1rem;
          cursor: pointer;
          background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; display: inline-block;
        }
        .button-like-label:hover { background-color: #e0e0e0; }
      `;
      document.head.appendChild(style);

      function updateCodeMaster() {
        const codeChecks = document.querySelectorAll(".code-check");
        const masterCodes = document.getElementById("checkAllCodes");
        masterCodes.checked =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        updateFormMaster();
      }
      function updateFormMaster() {
        const sectionsOk = sectionIds.every(
          (id) => document.getElementById(id).checked
        );
        const codeChecks = document.querySelectorAll(".code-check");
        const codesOk =
          codeChecks.length > 0 &&
          Array.from(codeChecks).every((c) => c.checked);
        document.getElementById("checkAllFields").checked =
          sectionsOk && codesOk;
      }
      function bindSectionCheckboxes() {
        sectionIds.concat("checkAllCodes").forEach((id) => {
          document.getElementById(id).addEventListener("change", () => {
            if (id === "checkAllCodes") {
              const checked = document.getElementById("checkAllCodes").checked;
              document
                .querySelectorAll(".code-check")
                .forEach((c) => (c.checked = checked));
            }
            updateFormMaster();
          });
        });
      }
      function createCodeRow(val = "") {
        const div = document.createElement("div");
        div.className = "code-item";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.className = "code-check";
        const inp = document.createElement("input");
        inp.type = "text";
        inp.value = val;
        const del = document.createElement("button");
        del.type = "button";
        del.textContent = "âœ–";
        del.addEventListener("click", () => {
          div.remove();
          updateCodeMaster();
        });
        chk.addEventListener("change", updateCodeMaster);
        div.append(chk, inp, del);
        return div;
      }
      function addCode(val = "") {
        const row = createCodeRow(val);
        document.getElementById("codesContainer").appendChild(row);
        updateCodeMaster();
      }
      document
        .getElementById("addCodeBtn")
        .addEventListener("click", () => addCode(""));
      document
        .getElementById("checkAllFields")
        .addEventListener("change", (e) => {
          const checked = e.target.checked;
          sectionIds
            .concat("checkAllCodes")
            .forEach((id) => (document.getElementById(id).checked = checked));
          document
            .querySelectorAll(".code-check")
            .forEach((c) => (c.checked = checked));
        });
      // Regex to find codes: alphanumeric with at least one digit, supporting Unicode letters (diacritics).
      // Handles precomposed and decomposed Unicode characters (e.g., letter + combining marks).
      // Using lookarounds for boundaries due to potential \b issues with some Unicode sequences.
      const CODE_REGEX =
        /(?:(?<=^)|(?<=[^\p{L}\p{N}_]))(?=.*\d)(?:[\p{L}0-9]\p{M}*){4,}(?:[ -](?:[\p{L}0-9]\p{M}*){4,})*(?:(?=$)|(?=[^\p{L}\p{N}_]))/gu;
      function parseRaw(raw) {
        const lines = raw.split(/\r?\n/);
        let service = "",
          login = "",
          note = "",
          dateText = "",
          codes = [];
        lines.forEach((l) => {
          let t = l.trim();
          if (!t) return;
          t = t.replace(/^\d+\.[ \t]*/, "").trim();
          if (/\b(?:wygenerowano|generated)[:]?/i.test(t)) {
            dateText = t.split(/[:]/).slice(1).join(":").trim();
            return;
          }
          if (/^\S+@\S+\.\S+$/.test(t) || /^\(.+@.+\)$/.test(t)) {
            login = t.replace(/^[()]+|[()]+$/g, "");
            return;
          }
          if (/^[*\-]\s/.test(t)) {
            note += t.replace(/^[*\-]\s*/, "") + " ";
            return;
          }
          const found = t.match(CODE_REGEX);
          if (found) {
            found.forEach((tok) => codes.push(tok.trim()));
            return;
          }
          if (!service && t.length < 50) {
            service = t;
          }
        });
        if (!dateText) dateText = new Date().toLocaleDateString();
        return { service, login, note: note.trim(), date: dateText, codes };
      }
      document.getElementById("parseBtn").addEventListener("click", () => {
        const raw = document.getElementById("rawInput").value;
        const rawInputError = document.getElementById("rawInputError");

        if (!raw.trim()) {
          rawInputError.textContent = "Please paste the raw text.";
          rawInputError.style.display = "block";
          return;
        }
        rawInputError.textContent = "";
        rawInputError.style.display = "none";

        const data = parseRaw(raw);
        document.getElementById("previewRaw").value = raw;
        ["service", "login", "note", "date"].forEach(
          (f) => (document.getElementById(f + "Input").value = data[f])
        );
        document.getElementById("codesContainer").innerHTML = "";
        data.codes.forEach((c) => addCode(c));
        [
          "checkService",
          "checkLogin",
          "checkAllCodes",
          "checkNote",
          "checkDate",
          "checkAllFields",
        ].forEach((id) => (document.getElementById(id).checked = false));
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("rawSection").style.display = "none";
        document.getElementById("editForm").style.display = "block";
        bindSectionCheckboxes();
        updateCodeMaster();
      });
      document.getElementById("cancelBtn").addEventListener("click", () => {
        document.getElementById("editForm").style.display = "none";
        document.getElementById("rawSection").style.display = "block";
        document.getElementById("errorMsg").textContent = "";
        document.getElementById("rawInputError").textContent = "";
        document.getElementById("rawInputError").style.display = "none";
      });

      let printQueue = [];

      function getCurrentFormData() {
        const err = document.getElementById("errorMsg");
        err.textContent = "";
        if (!document.getElementById("checkAllFields").checked) {
          err.textContent =
            "Please confirm that all sections and codes have been checked.";
          return null;
        }
        const srv = document.getElementById("serviceInput").value;
        const log = document.getElementById("loginInput").value;
        const notes = document.getElementById("noteInput").value;
        const dat = document.getElementById("dateInput").value;
        const items = Array.from(document.querySelectorAll(".code-item")).map(
          (d) => d.querySelector("input[type=text]").value
        );
        return {
          id: Date.now() + Math.random(), // Simple unique ID
          serviceName: srv,
          login: log,
          codes: items,
          note: notes,
          date: dat,
          originalRawInput: document.getElementById("previewRaw").value,
        };
      }

      function renderPrintQueue() {
        const queueList = document.getElementById("printQueueList");
        const queueStatus = document.getElementById("queueStatus");
        queueList.innerHTML = "";
        if (printQueue.length === 0) {
          queueStatus.style.display = "block";
          return;
        }
        queueStatus.style.display = "none";
        printQueue.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `${item.serviceName || "Untitled"} (${
            item.codes.length
          } codes)`;
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "Remove";
          removeBtn.style.marginLeft = "10px";
          removeBtn.onclick = () => {
            printQueue = printQueue.filter((i) => i.id !== item.id);
            renderPrintQueue();
          };
          li.appendChild(removeBtn);
          queueList.appendChild(li);
        });
      }

      document.getElementById("addToQueueBtn").addEventListener("click", () => {
        const formData = getCurrentFormData();
        if (formData) {
          printQueue.push(formData);
          renderPrintQueue();
          alert(`"${formData.serviceName || "Item"}" added to print queue.`);
          // Optionally, reset the form or switch view
          document.getElementById("cancelBtn").click(); // Simulate cancel to reset view
        }
      });

      document.getElementById("clearQueueBtn").addEventListener("click", () => {
        if (confirm("Are you sure you want to clear the entire print queue?")) {
          printQueue = [];
          renderPrintQueue();
        }
      });

      // Hoist generateBlockHtml to be accessible by PDF generation logic
      function generateBlockHtml(
        itemData,
        isFirstInPair = false,
        isPairOnPage = false
      ) {
        if (!itemData) return "";
        const codesHtml = itemData.codes
          .map(
            (v) => `<li><input type="checkbox" disabled /> ${v}</li>` // Removed 'checked'
          ) // Self-closed for tidiness
          .join("");
        // Add margin-right to the first block only if it's part of a pair on the page
        const blockStyle =
          isFirstInPair && isPairOnPage ? 'style="margin-right: 5mm;"' : "";

        return `<div class="block" ${blockStyle}><h2>${
          itemData.serviceName
        }</h2><p><strong>${itemData.login}</strong></p><ul>${codesHtml}</ul>${
          // h2 will use font-weight: bold from CSS
          itemData.note ? `<p><em>${itemData.note}</em></p>` : ""
        }<p class="date">${itemData.date}</p></div>`;
      }

      document
        .getElementById("printAllQueuedBtn")
        .addEventListener("click", () => {
          if (printQueue.length === 0) {
            alert("Print queue is empty.");
            return;
          }

          if (pdfModeActive) {
            generateAndDownloadPdf();
            return;
          }

          let allBlocksHtml = "";
          for (let i = 0; i < printQueue.length; i += 2) {
            allBlocksHtml += `<div class="print-page-container">`;
            const item1 = printQueue[i];
            allBlocksHtml += generateBlockHtml(item1);
            if (i + 1 < printQueue.length) {
              const item2 = printQueue[i + 1];
              allBlocksHtml += generateBlockHtml(item2);
            }
            allBlocksHtml += `</div>`;
          }

          const win = window.open("", "_blank");
          // Script to be injected into the new window.
          // It waits for fonts to be ready before printing.
          const injectedScript = `
            async function printWhenReady() {
              try {
                // Wait for all fonts specified in @font-face rules to be loaded and ready.
                await document.fonts.ready;
                // console.log('Fonts are ready, initiating print.');
                window.print();
              } catch (error) {
                console.error('Error waiting for fonts, printing anyway:', error);
                window.print(); // Fallback to print immediately if font check fails.
              }
            }

            // Call printWhenReady after the DOM is fully loaded.
            window.onload = printWhenReady;
          `;
          win.document.write(
            `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Print Codes</title><style>
@font-face {
  font-family: 'NotoSansUnicode';
  src: url('${FONT_PATH_GLOBAL}') format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'NotoSansUnicode';
  src: url('${FONT_PATH_GLOBAL_BOLD}') format('truetype');
  font-weight: bold;
  font-style: normal;
}
body {
  margin: 0;
  background-color: #f0f0f0; /* Preview background */
  display: flex; /* Center content in preview */
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}
body { font-family: 'NotoSansUnicode', sans-serif; font-weight: normal; } /* Apply Noto font to non-PDF print view */
.print-page-container { /* Container for one or two blocks in preview */
  display: flex;
  flex-direction: row;
  justify-content: center; /* Centers the block(s) within this container */
  align-items: flex-start;
  margin-bottom: 20px; /* Space between pairs in preview */
  /* Width will be determined by its content (one or two blocks with their margins) */
}
.block {
  width: 138mm; /* Reduced width to prevent overflow, matches PDF block width */
  height: 190mm; /* Approx. A5 landscape height, matches PDF block height */
  box-sizing: border-box;
  border: 1px solid #444;
  margin: 5mm; /* Spacing for preview */
  padding: 10mm;
  font-size: 10pt; /* Base font size for the block */
  background-color: white; /* White card background for preview */
  box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Subtle shadow for preview */
  overflow: hidden; /* Prevent content spill in preview */
  font-family: 'NotoSansUnicode', sans-serif; font-weight: normal; /* Ensure blocks also use Noto */
}
.block h2 {
  font-family: 'NotoSansUnicode', sans-serif; /* Explicitly set for h2 */
  font-weight: bold; /* Use the bold variant of NotoSansUnicode */
  font-size: 1.8em; margin-top: 0; margin-bottom: 0.6em; color: #333;
}
.block p { font-size: 1em; margin: 0.6em 0; line-height: 1.4; } /* line-height is 1.4 */
.block p strong { color: #000; font-weight: bold; } /* For login */
.block ul { font-size: 1em; padding-left: 0; margin: 0.8em 0; list-style-type: none; }
.block li { margin-bottom: 0.5em; display: flex; align-items: center; }
.block li input[type="checkbox"] {
  width: 3mm; /* Match PDF checkbox size */
  height: 3mm; /* Match PDF checkbox size */
  margin-right: 1.5mm; /* Match PDF checkbox text gap */
  flex-shrink: 0;
  vertical-align: middle; /* Adjust for better alignment with text */
}
.block .date { font-size: 0.9em; color: #555; margin-top: 1em; text-align: right; }
.block em { color: #444; font-style: normal; } /* For notes - remove italic */

/* Hide non-print elements if any were added to print window body */
.no-print { display: none; }

@media print {
  body { background-color: transparent; display: block; min-height: auto; margin:0; }
  .print-page-container {
    /* General styles for print-page-container */
    margin: 0; /* Reset preview margin */
    padding: 6mm; /* Overall page margin, similar to PDF's x_offset */
    box-sizing: border-box;
    width: 297mm; /* A4 landscape width */
    /* Let height be determined by content + padding, remove fixed height:
    height: 210mm; */
    display: flex;
    justify-content: flex-start; /* Align block(s) to the left of the padded area */
    align-items: center; /* Vertically center block(s) within the padded area */
    overflow: hidden; /* Prevent container itself from causing unexpected breaks */
  }
  /* Changed page break strategy: apply before instead of after */
  .print-page-container:not(:first-of-type) {
    page-break-before: always; /* Add page break before each container, except the first one */
  }
  .block {
    margin: 0; /* Reset preview margin, rely on container padding and flex gap */
    box-shadow: none;
    border: 1px solid #000; /* Match PDF border */
    /* width: 140mm and height: 190mm are already set */
    overflow: hidden; /* Good for print consistency */
  }
  /* Add margin to the first block if it's not the only block on the page */
  .print-page-container > .block:first-child:not(:last-child) {
    margin-right: 5mm; /* Space between the two blocks */
  }
}
</style></head><body>${allBlocksHtml}<script>${injectedScript}<\/script></body></html>`
          );
          win.document.close(); // Call close after writing content
        });
      document
        .getElementById("downloadJsonBtn")
        .addEventListener("click", () => {
          const srv = document.getElementById("serviceInput").value.trim();
          const log = document.getElementById("loginInput").value.trim();
          const notes = document.getElementById("noteInput").value.trim();
          const dat = document.getElementById("dateInput").value.trim();
          const items = Array.from(
            document.querySelectorAll(".code-item input[type=text]")
          ).map((input) => input.value.trim());

          const jsonData = {
            serviceName: srv,
            login: log,
            codes: items,
            note: notes,
            date: dat,
            originalRawInput: document.getElementById("previewRaw").value,
          };

          const jsonString = JSON.stringify(jsonData, null, 2); // null, 2 for pretty printing
          const blob = new Blob([jsonString], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${srv || "backup-codes"}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

      document
        .getElementById("uploadJsonInput")
        .addEventListener("change", function (event) {
          const files = event.target.files;
          if (!files.length) {
            return;
          }
          Array.from(files).forEach((file) => {
            const reader = new FileReader();
            reader.onload = function (e) {
              try {
                const jsonData = JSON.parse(e.target.result);
                // Basic validation for expected structure
                if (
                  jsonData &&
                  typeof jsonData.serviceName !== "undefined" &&
                  Array.isArray(jsonData.codes)
                ) {
                  jsonData.id = Date.now() + Math.random(); // Ensure unique ID
                  printQueue.push(jsonData);
                  renderPrintQueue();
                } else {
                  alert(
                    `File "${file.name}" does not have the expected JSON structure.`
                  );
                }
              } catch (error) {
                alert(
                  `Error parsing JSON from file "${file.name}": ${error.message}`
                );
              }
            };
            reader.readAsText(file);
          });
          // Reset file input to allow uploading the same file again if needed
          event.target.value = null;
        });

      async function generateAndDownloadPdf() {
        let base64FontRegular = await loadFontAsBase64(FONT_PATH_GLOBAL);
        let base64FontBold = await loadFontAsBase64(FONT_PATH_GLOBAL_BOLD);

        // --- End Font Embedding Logic ---

        if (!base64FontRegular) {
          // Check if the regular font failed to load
          // Alert is already shown in loadFontAsBase64 if it fails.
          // Decide if you want to proceed with default fonts or stop.
          // For now, we'll let it proceed, but characters might be wrong.
          console.warn(
            // Use console.warn for less intrusive message
            "Proceeding with PDF generation without custom font. Non-English characters may not display correctly."
          );
        }

        if (printQueue.length === 0) {
          alert("Print queue is empty for PDF generation.");
          return;
        }

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: "l", // landscape
          unit: "mm",
          format: "a4",
        });

        const pdfFontName = "NotoSansUnicode"; // Consistent font name
        // No need for pdfFontNameBold, jsPDF handles weights under the same family name

        if (base64FontRegular) {
          pdf.addFileToVFS(
            FONT_PATH_GLOBAL.split("/").pop(),
            base64FontRegular
          );
          pdf.addFont(FONT_PATH_GLOBAL.split("/").pop(), pdfFontName, "normal");
        }
        if (base64FontBold) {
          pdf.addFileToVFS(
            FONT_PATH_GLOBAL_BOLD.split("/").pop(),
            base64FontBold
          );
          pdf.addFont(
            FONT_PATH_GLOBAL_BOLD.split("/").pop(),
            pdfFontName,
            "bold"
          );
        }

        // Set default font for the PDF
        pdf.setFont(pdfFontName, "normal");

        // PDF Layout constants
        const PDF_PAGE_WIDTH = 297; // A4 landscape width in mm
        const PDF_PAGE_HEIGHT = 210; // A4 landscape height in mm
        const PDF_BLOCK_WIDTH = 138;
        const PDF_BLOCK_HEIGHT = 190;
        const PDF_INTER_BLOCK_MARGIN = 5; // mm
        const PDF_BLOCK_PADDING = 10; // Internal padding for content within a block

        // Font sizes (Points) - to match non-PDF mode more closely
        const PDF_TITLE_FONT_SIZE_PT = 18;
        const PDF_LOGIN_FONT_SIZE_PT = 10;
        const PDF_CODES_FONT_SIZE_PT = 10;
        const PDF_NOTE_FONT_SIZE_PT = 10;
        const PDF_DATE_FONT_SIZE_PT = 9;

        // Line & Margin constants (mm) - derived from non-PDF CSS
        const PT_TO_MM = 0.352778;
        const PDF_LINE_SPACING_FACTOR = 1.4; // Match non-PDF CSS line-height

        const PDF_TITLE_MARGIN_BOTTOM_MM = 2.2; // Approx 0.6em of 10pt
        const PDF_LOGIN_MARGIN_BOTTOM_MM = 2.2; // Approx 0.6em of 10pt
        const PDF_CODES_LIST_MARGIN_TOP_MM = 2.8; // Approx 0.8em of 10pt (ul margin-top)
        const PDF_CODE_ITEM_MARGIN_BOTTOM_MM = 1.8; // Approx 0.5em of 10pt (li margin-bottom)
        const PDF_CODES_LIST_MARGIN_BOTTOM_MM = 2.8; // Approx 0.8em of 10pt (ul margin-bottom)
        const PDF_NOTE_MARGIN_TOP_MM = 2.2; // Approx 0.6em (p margin-top)
        const PDF_NOTE_MARGIN_BOTTOM_MM = 2.2; // Approx 0.6em (p margin-bottom)
        // Date is positioned at bottom right; its top margin is effectively the remaining space or a fixed offset from note.

        const PDF_CHECKBOX_SIZE_MM = 3;
        const PDF_CHECKBOX_TEXT_GAP_MM = 1.5;

        for (let i = 0; i < printQueue.length; i += 2) {
          if (i > 0) {
            pdf.addPage("a4", "l");
            // Re-apply default font on new page, jsPDF might reset it
            if (base64FontRegular) {
              // Check if regular font was loaded
              pdf.setFont(pdfFontName, "normal");
            } else {
              // Fallback if NotoSans-Regular wasn't loaded, jsPDF will use a default
            }
          }

          const itemsOnPage = [];
          if (printQueue[i]) itemsOnPage.push(printQueue[i]);
          if (i + 1 < printQueue.length) itemsOnPage.push(printQueue[i + 1]);

          // Calculate starting X position. If one item, it takes the left slot.
          const startXForAllBlocks =
            (PDF_PAGE_WIDTH - (PDF_BLOCK_WIDTH * 2 + PDF_INTER_BLOCK_MARGIN)) /
            2;
          const blockY = (PDF_PAGE_HEIGHT - PDF_BLOCK_HEIGHT) / 2;

          itemsOnPage.forEach((itemData, indexOnPage) => {
            if (!itemData) return;

            const itemX =
              startXForAllBlocks +
              indexOnPage * (PDF_BLOCK_WIDTH + PDF_INTER_BLOCK_MARGIN);
            let currentY = blockY + PDF_BLOCK_PADDING; // Start Y inside padding

            // Draw block border
            pdf.setDrawColor(0); // Black
            pdf.rect(itemX, blockY, PDF_BLOCK_WIDTH, PDF_BLOCK_HEIGHT);

            // Service Name
            pdf.setFont(pdfFontName, "bold"); // Use bold variant
            pdf.setFontSize(PDF_TITLE_FONT_SIZE_PT);
            const titleText = itemData.serviceName || "Untitled";
            const titleLineHeightMm =
              PDF_TITLE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
            pdf.text(titleText, itemX + PDF_BLOCK_PADDING, currentY, {
              // charSpace: 0.1, // Optional: if you want letter spacing
            });
            currentY += titleLineHeightMm + PDF_TITLE_MARGIN_BOTTOM_MM;

            // Login
            pdf.setFont(pdfFontName, "normal"); // Switch back to normal weight
            pdf.setFontSize(PDF_LOGIN_FONT_SIZE_PT);
            const loginText = itemData.login || "";
            const loginLineHeightMm =
              PDF_LOGIN_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
            // For strong tag, jsPDF doesn't directly support nested font weights in one text call.
            // We'll render it as normal weight here. If true bold for login is needed, it'd require separate text calls.
            pdf.text(loginText, itemX + PDF_BLOCK_PADDING, currentY);
            currentY += loginLineHeightMm + PDF_LOGIN_MARGIN_BOTTOM_MM;

            // Codes
            pdf.setFont(pdfFontName, "normal"); // Ensure normal weight for codes
            currentY += PDF_CODES_LIST_MARGIN_TOP_MM;
            const codes = itemData.codes || [];
            const textMaxWidthForCode =
              PDF_BLOCK_WIDTH -
              PDF_BLOCK_PADDING * 2 -
              PDF_CHECKBOX_SIZE_MM -
              PDF_CHECKBOX_TEXT_GAP_MM;

            const codesStartY = currentY;
            let codesContentHeight = 0;

            codes.forEach((code) => {
              pdf.setFontSize(PDF_CODES_FONT_SIZE_PT);
              const codeSingleLineHeightMm =
                PDF_CODES_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              const codeLines = pdf.splitTextToSize(code, textMaxWidthForCode);
              const thisCodeBlockHeight =
                codeLines.length * codeSingleLineHeightMm +
                PDF_CODE_ITEM_MARGIN_BOTTOM_MM;

              // Simplified overflow check: estimate remaining space for date and note
              const estimatedDateHeight =
                PDF_DATE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR + 5; // 5mm for margin/buffer
              const estimatedNoteHeight = itemData.note
                ? PDF_NOTE_FONT_SIZE_PT *
                    PT_TO_MM *
                    PDF_LINE_SPACING_FACTOR *
                    2 +
                  PDF_NOTE_MARGIN_TOP_MM +
                  PDF_NOTE_MARGIN_BOTTOM_MM +
                  5
                : 0; // rough estimate for 2 lines + margins
              const maxCodesY =
                blockY +
                PDF_BLOCK_HEIGHT -
                PDF_BLOCK_PADDING -
                estimatedDateHeight -
                estimatedNoteHeight -
                PDF_CODES_LIST_MARGIN_BOTTOM_MM;

              if (
                currentY + thisCodeBlockHeight > maxCodesY &&
                codesContentHeight > 0 // Allow at least one code if it fits initially
              ) {
                return;
              }

              // Draw checkbox (simple square)
              pdf.rect(
                itemX + PDF_BLOCK_PADDING,
                currentY - PDF_CHECKBOX_SIZE_MM * 0.75, // Align with text baseline
                PDF_CHECKBOX_SIZE_MM,
                PDF_CHECKBOX_SIZE_MM
              );
              // No checkmark, as per request for unchecked boxes

              let tempY = currentY;
              for (const line of codeLines) {
                pdf.text(
                  line,
                  itemX +
                    PDF_BLOCK_PADDING +
                    PDF_CHECKBOX_SIZE_MM +
                    PDF_CHECKBOX_TEXT_GAP_MM,
                  tempY
                );
                tempY += codeSingleLineHeightMm;
              }
              currentY += thisCodeBlockHeight;
              codesContentHeight += thisCodeBlockHeight;
            });
            if (codesContentHeight > 0) {
              // Only add bottom margin if codes were drawn
              currentY =
                codesStartY +
                codesContentHeight -
                PDF_CODE_ITEM_MARGIN_BOTTOM_MM +
                PDF_CODES_LIST_MARGIN_BOTTOM_MM;
            } else {
              // No codes drawn, remove the top margin for the list
              currentY -= PDF_CODES_LIST_MARGIN_TOP_MM;
            }

            // Note (if exists, position towards bottom)
            const dateLineHeightMm =
              PDF_DATE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
            const dateAreaHeightWithMargin = itemData.date
              ? dateLineHeightMm + 5
              : 0; // 5mm buffer for date margin
            let noteAvailableYStart = currentY; // Start note after codes

            if (itemData.note) {
              currentY += PDF_NOTE_MARGIN_TOP_MM;
              pdf.setFont(pdfFontName, "normal"); // No italics for note
              pdf.setFontSize(PDF_NOTE_FONT_SIZE_PT);
              const noteSingleLineHeightMm =
                PDF_NOTE_FONT_SIZE_PT * PT_TO_MM * PDF_LINE_SPACING_FACTOR;
              const noteLines = pdf.splitTextToSize(
                itemData.note,
                PDF_BLOCK_WIDTH - PDF_BLOCK_PADDING * 2
              );
              let noteContentHeight = 0;
              for (const line of noteLines) {
                if (
                  currentY + noteSingleLineHeightMm >
                  blockY +
                    PDF_BLOCK_HEIGHT -
                    PDF_BLOCK_PADDING -
                    dateAreaHeightWithMargin
                ) {
                  break; // Stop if note overflows into date area
                }
                pdf.text(line, itemX + PDF_BLOCK_PADDING, currentY);
                currentY += noteSingleLineHeightMm;
                noteContentHeight += noteSingleLineHeightMm;
              }
              if (noteContentHeight > 0) {
                currentY += PDF_NOTE_MARGIN_BOTTOM_MM;
              } else {
                // No note drawn, remove top margin
                currentY -= PDF_NOTE_MARGIN_TOP_MM;
              }
            }

            // Date (if exists, position at bottom right)
            if (itemData.date) {
              pdf.setFont(pdfFontName, "normal"); // Ensure normal weight for date
              pdf.setFontSize(PDF_DATE_FONT_SIZE_PT);
              const dateYPos =
                blockY +
                PDF_BLOCK_HEIGHT -
                PDF_BLOCK_PADDING -
                dateLineHeightMm * 0.3; // Position baseline slightly above bottom padding edge
              const dateTextWidth =
                (pdf.getStringUnitWidth(itemData.date) *
                  PDF_DATE_FONT_SIZE_PT) /
                pdf.internal.scaleFactor;
              pdf.text(
                itemData.date,
                itemX + PDF_BLOCK_WIDTH - PDF_BLOCK_PADDING - dateTextWidth,
                dateYPos
              );
            }
          });
        }
        pdf.save("backup-codes.pdf");
      }

      async function loadFontAsBase64(fontUrl) {
        try {
          const response = await fetch(fontUrl);
          if (!response.ok) {
            throw new Error(
              `Failed to load font: ${response.statusText} (URL: ${fontUrl})`
            );
          }
          const fontBuffer = await response.arrayBuffer();
          let binary = "";
          const bytes = new Uint8Array(fontBuffer);
          const len = bytes.byteLength;
          for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        } catch (error) {
          console.error(error);
          console.warn(
            // Use console.warn for less intrusive message
            `Error loading font from ${fontUrl}: ${error.message}. PDF might not render special characters correctly.`
          );
          return null; // Return null if font loading fails
        }
      }

      renderPrintQueue(); // Initial render of the queue (will show empty message)
    </script>
  </body>
</html>
